<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[我的Makefile总结]]></title>
    <url>%2F2017%2F09%2F22%2F%E6%88%91%E7%9A%84Makefile%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Makefile规则一句话总结就是依赖关系，简单如下所示target … : prerequisites …command……target也就是一个目标文件，能够是Object File，也能够是运行文件。还能够是一个标签（Label），对于标签这样的特性，在后续的“伪目标”章节中会有叙述。prerequisites就是，要生成那个target所须要的文件或是目标。command也就是make须要运行的命令。（随意的Shell命令）这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。说白一点就是说，prerequisites中假设有一个以上的文件比target文件要新的话，command所定义的命令就会被运行。这就是Makefile的规则。也就是Makefile中最核心的内容。 Makefile 工作1、make会在当前文件夹下找名字叫“Makefile”或“makefile”的文件。2、假设找到，它会找文件里的第一个目标文件（target），在上面的样例中，他会找到“edit”这个文件，并把这个文件作为终于的目标文件。3、假设edit文件不存在，或是edit所依赖的后面的 .o 文件的文件改动时间要比edit这个文件新，那么，他就会运行后面所定义的命令来生成edit这个文件。4、假设edit所依赖的.o文件也不存在，那么make会在当前文件里找目标为.o文件的依赖性，假设找到则再依据那一个规则生成.o文件。（这有点像一个堆栈的过程）5、当然，你的C文件和H文件是存在的啦，于是make会生成 .o 文件，然后再用 .o 文件生命make的终极任务，也就是运行文件edit了。 Makefile 内容Makefile里主要包括了五个东西：显式规则、隐晦规则、变量定义、文件指示和凝视。1、显式规则。显式规则说明了，怎样生成一个或多的的目标文件。这是由Makefile的书写者明显指出，要生成的文件，文件的依赖文件，生成的命令。2、隐晦规则。由于我们的make有自己主动推导的功能，所以隐晦的规则能够让我们比較粗糙地简略地书写Makefile，这是由make所支持的。3、变量的定义。在Makefile中我们要定义一系列的变量，变量一般都是字符串，这个有点你C语言中的宏，当Makefile被运行时，当中的变量都会被扩展到对应的引用位置上。4、文件指示。其包括了三个部分，一个是在一个Makefile中引用另一个Makefile，就像C语言中的include一样；另一个是指依据某些情况指定Makefile中的有效部分，就像C语言中的预编译#if一样；还有就是定义一个多行的命令。有关这一部分的内容，我会在后续的部分中讲述。5、凝视。Makefile中唯独行凝视，和UNIX的Shell脚本一样，其凝视是用“#”字符，这个就像C/C++中的“//”一样。假设你要在你的Makefile中使用“#”字符，能够用反斜框进行转义，如：“/#”。最后，还值得一提的是，在Makefile中的命令，必须要以[Tab]键开始。 make的工作方式GNU的make工作时的运行步骤入下：（想来其他的make也是相似）1、读入全部的Makefile。2、读入被include的其他Makefile。3、初始化文件里的变量。4、推导隐晦规则，并分析全部规则。5、为全部的目标文件创建依赖关系链。6、依据依赖关系，决定哪些目标要又一次生成。7、运行生成命令。1-5步为第一个阶段，6-7为第二个阶段。第一个阶段中，假设定义的变量被使用了，那么，make会把其展开在使用的位置。但make并不会全然立即展开，make使用的是迟延战术，假设变量出如今依赖关系的规则中，那么仅当这条依赖被决定要使用了，变量才会在其内部展开 通配符make支持三各通配符：“*”，“?”和“[…]”。这是和Unix的B-Shell是相同的。波浪号（“~”）字符在文件名称中也有比較特殊的用途。假设是“~/test”，这就表示当前用户的$HOME文件夹下的test文件夹 文件搜寻在一些大的工程中，有大量的源文件，我们通常的做法是把这很多的源文件分类，并存放在不同的文件夹中。所以，当make须要去找寻文件的依赖关系时，你能够在文件前加上路径，但最好的方法是把一个路径告诉make，让make在自己主动去找。Makefile文件里的特殊变量“VPATH”就是完成这个功能的，假设沒有指明这个变量，make仅仅会在当前的文件夹中去找寻依赖文件和目标文件。假设定义了这个变量，那么，make就会在当当前文件夹找不到的情况下，到所指定的文件夹中去找寻文件了。VPATH = src:../headers上面的的定义指定两个文件夹，“src”和“../headers”，make会依照这个顺序进行搜索。文件夹由“冒号”分隔。（当然，当前文件夹永远是最高优先搜索的地方）另一个设置文件搜索路径的方法是使用make的“vpath”keyword（注意，它是全小写的），这不是变量，这是一个make的keyword，这和上面提到的那个VPATH变量非常相似，可是它更为灵活。它能够指定不同的文件在不同的搜索文件夹中。这是一个非常灵活的功能。它的使用方法有三种：1、vpath 为符合模式的文件指定搜索文件夹。2、vpath 清除符合模式的文件的搜索文件夹。3、vpath清除全部已被设置好了的文件搜索文件夹。vapth使用方法中的须要包括“%”字符。“%”的意思是匹配零或若干字符，比如，“%.h”表示全部以“.h”结尾的文件。指定了要搜索的文件集，而则指定了的文件集的搜索的文件夹。比如：vpath %.h ../headers该语句表示，要求make在“../headers”文件夹下搜索全部以“.h”结尾的文件。（假设某文件在当前文件夹沒有找到的话）我们能够连续地使用vpath语句，以指定不同搜索策略。假设连续的vpath语句中出现了相同的，或是被反复了的，那么，make会依照vpath语句的先后顺序来运行搜索。如：vpath %.c foovpath % blishvpath %.c bar其表示“.c”结尾的文件，先在“foo”文件夹，然后是“blish”，最后是“bar”文件夹。vpath %.c foo:barvpath % blish而上面的语句则表示“.c”结尾的文件，先在“foo”文件夹，然后是“bar”文件夹，最后才是“blish”文件夹 伪目标最早先的一个样例中，我们提到过一个“clean”的目标，这是一个“伪目标”，clean:rm .o temp正像我们前面样例中的“clean”一样，即然我们生成了很多文件编译文件，我们也应该提供一个清除它们的“目标”以备完整地重编译而用。 （以“make clean”来使用该目标）由于，我们并不生成“clean”这个文件。“伪目标”并非一个文件，仅仅是一个标签，由于“伪目标”不是文件，所以make无法生成它的依赖关系和决定它是否要运行。我们唯独通过显示地指明这个“目标”才干让其生效。当然，“伪目标”的取名不能和文件名称重名，不然其就失去了“伪目标”的意义了。当然，为了避免和文件重名的这样的情况，我们能够使用一个特殊的标记“.PHONY”来显示地指明一个目标是“伪目标”，向make说明，无论是否有这个文件，这个目标就是“伪目标”。.PHONY : clean仅仅要有这个声明，无论是否有“clean”文件，要运行“clean”这个目标，唯独“make clean”这样。于是整个过程能够这样写：.PHONY: cleanclean:rm .o temp伪目标一般沒有依赖的文件。可是，我们也能够为伪目标指定所依赖的文件。伪目标相同能够作为“默认目标”，仅仅要将其放在第一个。一个演示例子就是，假设你的Makefile须要一口气生成若干个可运行文件，但你仅仅想简单地敲一个make完事，而且，全部的目标文件都写在一个Makefile中，那么你能够使用“伪目标”这个特性：all : prog1 prog2 prog3.PHONY : allprog1 : prog1.o utils.occ -o prog1 prog1.o utils.oprog2 : prog2.occ -o prog2 prog2.oprog3 : prog3.o sort.o utils.occ -o prog3 prog3.o sort.o utils.o我们知道，Makefile中的第一个目标会被作为其默认目标。我们声明了一个“all”的伪目标，其依赖于其他三个目标。由于伪目标的特性是，总是被运行的，所以其依赖的那三个目标就总是不如“all”这个目标新。所以，其他三个目标的规则总是会被决议。也就达到了我们一口气生成多个目标的目的。“.PHONY : all”声明了“all”这个目标为“伪目标”。随便提一句，从上面的样例我们能够看出，目标也能够成为依赖。所以，伪目标相同也可成为依赖。看以下的样例：.PHONY: cleanall cleanobj cleandiffcleanall : cleanobj cleandiffrm programcleanobj :rm .ocleandiff :rm .diff“make clean”将清除全部要被清除的文件。“cleanobj”和“cleandiff”这两个伪目标有点像“子程序”的意思。我们能够输入“make cleanall”和“make cleanobj”和“make cleandiff”命令来达到清除不同种类文件的目的。 ##内容很多，在此停顿，详情参考下列文章makefile参考文章下面提供两个模板很nice 很perfect 模板一//最终可执行程序TGT=edns_dial //所有源代码的集合SRCS=$(wildcard ./src/*.cpp) // 编译所需库文件 静态库指明路径LIBRAYS= -levent -lrt -pthread -lssl -lcrypto -ldl -lz ./lib/*.a // 编译所需头文件路径COMPILE_FLAGS= -g -W -O2 -DHAVE_NETINET_IN_H -I. -I./include -I./clib/include -I/usr/include/glib-2.0 -I/usr/lib64/glib-2.0/include/ -I/usr/include/openssl // 编译器CC=g++ // 最终all:$(TGT) @echo Generation target! // 生成最终可执行程序 $@表示目标的集合 $^表示以来的集合$(TGT):$(SRCS:.cpp=.o) $(CC) -o $@ $^ $(LIBRAYS) $(COMPILE_FLAGS) //以下这个样例表示了,把全部的[.cpp]文件都编译成[.o]文件%.o : %.cpp $(CC) -c $(COMPILE_FLAGS) $&lt; -o $@ // 伪目标.PHONY: clean install // 删除清理clean: rm -rf $(TGT) $(SRCS:.cpp=.o) // 制作rpm所需的宏RPM_VERSION = 1.1.1.8COMMIT = $(shell git rev-list HEAD |head -1|cut -c 1-6)RPMRELEASE = $(shell git branch –no-color 2&gt; /dev/null | sed -e ‘/^[^]/d’ -e ‘s/ (.*)/\1/‘ -e ‘s/-//g’)_$(COMMIT)RPM_RELEASE = enterpriseRPM_TOP_DIR = $(shell rpm -E %{_topdir})PRJHOME = $(shell pwd) // rpm包制作rpm: @echo [RPM] ; \ sed -e “s/@VERSION@/$(RPM_VERSION)/g” -e “s/@RELEASE@/$(RPM_RELEASE)/g” $(TGT).spec.tmp &gt; ${RPM_TOP_DIR}/SPECS/$(TGT).spec ; \ cp -a -r ${PRJHOME} /tmp/$(TGT)-$(RPM_VERSION) ; \ cd /tmp ; \ tar zcvf $(RPM_TOP_DIR)/SOURCES/$(TGT)-$(RPM_VERSION).tar.gz $(TGT)-$(RPM_VERSION) ; \ rm -rf $(TGT)-$(RPM_VERSION) ; \ rpmbuild -bb $(RPM_TOP_DIR)/SPECS/$(TGT).spec ; \ // rpm 清理rpmclean: cp -r ~/rpmbuild/RPMS/x86_64/$(TGT)$(RPM_VERSION) ./ rm -rf ~/rpmbuild/SOURCES/$(TGT) \ ~/rpmbuild/BUILD/$(TGT) \ ~/rpmbuild/RPMS/x86_64/$(TGT) \ ~/rpmbuild/SPEC/$(TGT) 模板二TGT=edns_dial SRCS=$(wildcard *.cpp)TOP=$(shell pwd) LIBRAYS= -levent -lrt -pthread -lssl -lcrypto -ldl -lz ./lib/*.aCOMPILE_FLAGS= -g -W -O2 -DHAVE_NETINET_IN_H -I. -I./include -I./clib/include -I/usr/include/glib-2.0 -I/usr/lib64/glib-2.0/include/ -I/usr/include/openssl TGT_PLACE=$(TOP)/outDEP=dep CC=g++DIAL_PACKET=dial_query.tar.gzINSTALL_PACKET=dial_core_install.bin.tar RPM_VERSION = 1.1.1.8COMMIT = $(shell git rev-list HEAD |head -1|cut -c 1-6)RPMRELEASE = $(shell git branch –no-color 2&gt; /dev/null | sed -e ‘/^[^]/d’ -e ‘s/ (.*)/\1/‘ -e ‘s/-//g’)_$(COMMIT)RPM_RELEASE = enterpriseRPM_TOP_DIR = $(shell rpm -E %{_topdir})PRJHOME = $(shell pwd) all:$(TGT) cp $(TGT) $(TGT_PLACE) @echo Generation target! $(TGT):$(SRCS:.cpp=.o) $(CC) -o $@ $^ $(LIBRAYS) $(COMPILE_FLAGS) $(SRCS:.cpp=.o): $(CC) -c $&lt; $(COMPILE_FLAGS) $(DEP): $(SRCS) $(CC) -I $(TOP)/include/ -MM $(SRCS) &gt; $@ sed -i “s/: / $@: /g” $@ sinclude $(DEP) .PHONY: clean install clean: rm -rf $(TGT) $(DEP) $(SRCS:.cpp=.o) $(TGT_PLACE) rpm: @echo [RPM] ; \ sed -e “s/@VERSION@/$(RPM_VERSION)/g” -e “s/@RELEASE@/$(RPM_RELEASE)/g” edns_dial.spec.tmp &gt; ${RPM_TOP_DIR}/SPECS/edns_dial.spec ; \ cp -a -r ${PRJHOME} /tmp/edns_dial-$(RPM_VERSION) ; \ cd /tmp ; \ tar zcvf $(RPM_TOP_DIR)/SOURCES/edns_dial-$(RPM_VERSION).tar.gz edns_dial-$(RPM_VERSION) ; \ rm -rf edns_dial-$(RPM_VERSION) ; \ rpmbuild -bb $(RPM_TOP_DIR)/SPECS/edns_dial.spec]]></content>
      <categories>
        <category>linux基础</category>
        <category>Makefile</category>
      </categories>
      <tags>
        <tag>inux</tag>
        <tag>makefile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux内核之原子操作]]></title>
    <url>%2F2017%2F09%2F20%2Flinux%E5%86%85%E6%A0%B8%E4%B9%8B%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[在单处理器情况下，每条指令的执行都是原子性的，但在多处理器情况下，只有那些单独的读操作或写操作才是原子性的。为了弥补这一缺点，x86提供了附加的lock前缀，使带lock前缀的读修改写指令也能原子性执行。带lock前缀的指令在操作时会锁住总线，使自身的执行即使在多处理器间也是原子性执行的。xchg指令不带lock前缀也是原子性执行，也就是说xchg执行时默认会锁内存总线。原子性操作是线程间同步的基础，linux专门定义了一种只进行原子操作的类型atomic_t，并提供相关的原子读写调用API。本节就来分析这些原子操作在x86下的实现。 typedef struct { volatile int counter; } atomic_t;原子类型其实是int类型，只是禁止寄存器对其暂存。 #define ATOMIC_INIT(i) { (i) }原子类型的初始化。32位x86平台下atomic API在arch/x86/include/asm/atomic_32.h中实现。 static inline int atomic_read(const atomic_t *v) { return v-&gt;counter; } static inline void atomic_set(atomic_t *v, int i) { v-&gt;counter = i; }单独的读操作或者写操作，在x86下都是原子性的。 static inline void atomic_add(int i, atomic_t *v) { asm volatile(LOCK_PREFIX “addl %1,%0” : “+m” (v-&gt;counter) : “ir” (i)); } static inline void atomic_sub(int i, atomic_t *v) { asm volatile(LOCK_PREFIX “subl %1,%0” : “+m” (v-&gt;counter) : “ir” (i)); }atomic_add和atomic_sub属于读修改写操作，实现时需要加lock前缀。 static inline int atomic_sub_and_test(int i, atomic_t *v) { unsigned char c; asm volatile(LOCK_PREFIX “subl %2,%0; sete %1” : “+m” (v-&gt;counter), “=qm” (c) : “ir” (i) : “memory”); return c; }atomic_sub_and_test执行完减操作后检查结果是否为0。 static inline void atomic_inc(atomic_t *v) { asm volatile(LOCK_PREFIX “incl %0” : “+m” (v-&gt;counter)); } static inline void atomic_dec(atomic_t *v) { asm volatile(LOCK_PREFIX “decl %0” : “+m” (v-&gt;counter)); }atomic_inc和atomic_dec是递增递减操作。 static inline int atomic_dec_and_test(atomic_t *v) { unsigned char c; asm volatile(LOCK_PREFIX “decl %0; sete %1” : “+m” (v-&gt;counter), “=qm” (c) : : “memory”); return c != 0; }atomic_dec_and_test在递减后检查结果是否为0。 static inline int atomic_inc_and_test(atomic_t *v) { unsigned char c; asm volatile(LOCK_PREFIX “incl %0; sete %1” : “+m” (v-&gt;counter), “=qm” (c) : : “memory”); return c != 0; }atomic_inc_and_test在递增后检查结果是否为0。 static inline int atomic_add_negative(int i, atomic_t *v) { unsigned char c; asm volatile(LOCK_PREFIX “addl %2,%0; sets %1” : “+m” (v-&gt;counter), “=qm” (c) : “ir” (i) : “memory”); return c; }atomic_add_negative在加操作后检查结果是否为负数。 static inline int atomic_add_return(int i, atomic_t *v) { int __i; #ifdef CONFIG_M386 unsigned long flags; if (unlikely(boot_cpu_data.x86 &lt;= 3)) goto no_xadd; #endif / Modern 486+ processor / __i = i; asm volatile(LOCK_PREFIX “xaddl %0, %1” : “+r” (i), “+m” (v-&gt;counter) : : “memory”); return i + __i; #ifdef CONFIG_M386 no_xadd: / Legacy 386 processor / local_irq_save(flags); __i = atomic_read(v); atomic_set(v, i + __i); local_irq_restore(flags); return i + __i; #endif }atomic_add_return 不仅执行加操作，而且把相加的结果返回。它是通过xadd这一指令实现的。 static inline int atomic_sub_return(int i, atomic_t *v) { return atomic_add_return(-i, v); }atomic_sub_return 不仅执行减操作，而且把相减的结果返回。它是通过atomic_add_return实现的。 static inline int atomic_cmpxchg(atomic_t *v, int old, int new) { return cmpxchg(&amp;v-&gt;counter, old, new); } #define cmpxchg(ptr, o, n) \ ((typeof(*(ptr)))__cmpxchg((ptr), (unsigned long)(o), \ (unsigned long)(n), \ sizeof(*(ptr)))) static inline unsigned long __cmpxchg(volatile void *ptr, unsigned long old, unsigned long new, int size) { unsigned long prev; switch (size) { case 1: asm volatile(LOCK_PREFIX “cmpxchgb %b1,%2” : “=a”(prev) : “q”(new), “m”(*__xg(ptr)), “0”(old) : “memory”); return prev; case 2: asm volatile(LOCK_PREFIX “cmpxchgw %w1,%2” : “=a”(prev) : “r”(new), “m”(*__xg(ptr)), “0”(old) : “memory”); return prev; case 4: asm volatile(LOCK_PREFIX “cmpxchgl %k1,%2” : “=a”(prev) : “r”(new), “m”(*__xg(ptr)), “0”(old) : “memory”); return prev; case 8: asm volatile(LOCK_PREFIX “cmpxchgq %1,%2” : “=a”(prev) : “r”(new), “m”(*__xg(ptr)), “0”(old) : “memory”); return prev; } return old; }atomic_cmpxchg是由cmpxchg指令完成的。它把旧值同atomic_t类型的值相比较，如果相同，就把新值存入atomic_t类型的值中，返回atomic_t类型变量中原有的值。 static inline int atomic_xchg(atomic_t *v, int new) { return xchg(&amp;v-&gt;counter, new); } #define xchg(ptr, v) \ ((typeof((ptr)))__xchg((unsigned long)(v), (ptr), sizeof((ptr)))) static inline unsigned long __xchg(unsigned long x, volatile void *ptr, int size) { switch (size) { case 1: asm volatile(“xchgb %b0,%1” : “=q” (x) : “m” (*__xg(ptr)), “0” (x) : “memory”); break; case 2: asm volatile(“xchgw %w0,%1” : “=r” (x) : “m” (*__xg(ptr)), “0” (x) : “memory”); break; case 4: asm volatile(“xchgl %k0,%1” : “=r” (x) : “m” (*__xg(ptr)), “0” (x) : “memory”); break; case 8: asm volatile(“xchgq %0,%1” : “=r” (x) : “m” (*__xg(ptr)), “0” (x) : “memory”); break; } return x; }atomic_xchg则是将新值存入atomic_t类型的变量，并将变量的旧值返回。它使用xchg指令实现。 /** atomic_add_unless - add unless the number is already a given value @v: pointer of type atomic_t @a: the amount to add to v… @u: …unless v is equal to u. * Atomically adds @a to @v, so long as @v was not already @u. Returns non-zero if @v was not @u, and zero otherwise. */ static inline int atomic_add_unless(atomic_t *v, int a, int u) { int c, old; c = atomic_read(v); for (;;) { if (unlikely(c == (u))) break; old = atomic_cmpxchg((v), c, c + (a)); if (likely(old == c)) break; c = old; } return c != (u); }atomic_add_unless的功能比较特殊。它检查v是否等于u，如果不是则把v的值加上a，返回值表示相加前v是否等于u。因为在atomic_read和atomic_cmpxchg中间可能有其它的写操作，所以要循环检查自己的值是否被写进去。 #define atomic_inc_not_zero(v) atomic_add_unless((v), 1, 0) #define atomic_inc_return(v) (atomic_add_return(1, v)) #define atomic_dec_return(v) (atomic_sub_return(1, v))atomic_inc_not_zero在v值不是0时加1。atomic_inc_return对v值加1，并返回相加结果。atomic_dec_return对v值减1，并返回相减结果。 #define atomic_clear_mask(mask, addr) \ asm volatile(LOCK_PREFIX “andl %0,%1” \ : : “r” (~(mask)), “m” (*(addr)) : “memory”)atomic_clear_mask清除变量某些位。 #define atomic_set_mask(mask, addr) \ asm volatile(LOCK_PREFIX “orl %0,%1” \ : : “r” (mask), “m” (*(addr)) : “memory”)atomic_set_mask将变量的某些位置位。 / Atomic operations are already serializing on x86 / #define smp_mb__before_atomic_dec() barrier() #define smp_mb__after_atomic_dec() barrier() #define smp_mb__before_atomic_inc() barrier() #define smp_mb__after_atomic_inc() barrier()因为x86的atomic操作大多使用原子指令或者带lock前缀的指令。带lock前缀的指令执行前会完成之前的读写操作，对于原子操作来说不会受之前对同一位置的读写操作，所以这里只是用空操作barrier()代替。barrier()的作用相当于告诉编译器这里有一个内存屏障，放弃在寄存器中的暂存值，重新从内存中读入。本节的atomic_t类型操作是最基础的，为了介绍下面的内容，必须先介绍它。如果可以使用atomic_t类型代替临界区操作，也可以加快不少速度。]]></content>
      <categories>
        <category>linux内核</category>
      </categories>
      <tags>
        <tag>linux基础</tag>
        <tag>atomic</tag>
        <tag>linux内核</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的git使用]]></title>
    <url>%2F2017%2F09%2F19%2F%E6%88%91%E7%9A%84git%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[引言安装gityum apt 均可 Git add将当前工作目录中更改或者新增的文件加入到Git的索引中，加入到Git的索引中就表示记入了版本历史中，这也是提交之前所需要执行的一步。可以递归添加，即如果后面跟的是一个目录作为参数，则会递归添加整个目录中的所有子目录和文件。例如： git add dir1 （ 添加dir1这个目录，目录下的所有文件都被加入 ） Git add f1 f2 （ 添加f1，f2文件） git add . ( 添加当前目录下的所有文件和子目录 ) Git commit提交当前工作目录的修改内容。直接调用git commit命令，会提示填写注释。通过如下方式在命令行就填写提交注释：git commit -m “Initial commit of gittutor reposistory”。 注意，和CVS不同，git的提交注释必须不能为空，否则就会提交失败。git commit还有一个 -a的参数，可以将那些没有通过git add标识的变化一并强行提交，但是不建议使用这种方式。每一次提交，git就会为全局代码建立一个唯一的commit标识代码，用户可以通过git reset命令恢复到任意一次提交时的代码。git commit –-amend –m “message” （在一个commit id上不断修改提交的内容） Git status查看版本库的状态。可以得知哪些文件发生了变化，哪些文件还没有添加到git库中等等。建议每次commit前都要通过该命令确认库状态。最常见的误操作是， 修改了一个文件， 没有调用git add通知git库该文件已经发生了变化就直接调用commit操作，从而导致该文件并没有真正的提交。这时如果开发者以为已经提交了该文件，就继续修改甚至删除这个文件，那么修改的内容就没有通过版本管理起来。如果每次在 提交前，使用git status查看一下，就可以发现这种错误。因此，如果调用了git status命令，一定要格外注意那些提示为 “Changed but not updated:”的文件。这些文件都是与上次commit相比发生了变化，但是却没有通过git add标识的文件。 初始化一个Git仓库，使用git init命令。添加文件到Git仓库，分两步：第一步，使用命令git add ，注意，可反复多次使用，添加多个文件；第二步，使用命令git commit，完成。 要随时掌握工作区的状态，使用git status命令。如果git status告诉你有文件被修改过，用git diff可以查看修改内容 Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交3628164…882e1e0（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。git reset –hard HEAD^ Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向append GPLHEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset –hard commit_id。穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。 git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支。git commit只负责把暂存区的修改提交了 git checkout – file可以丢弃工作区的修改：命令git checkout – readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况：一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。总之，就是让这个文件回到最近一次git commit或git add时的状态。 Git同样告诉我们，用命令git reset HEAD file可以把暂存区的修改撤销掉（unstage），重新放回工作区：场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout – file。场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。 一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了：$ rm test.txt这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了：现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit现在，文件就从版本库中被删除了。另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：$ git checkout – test.txtgit checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。 关联要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git；关联后，使用命令git push -u origin master第一次推送master分支的所有内容；此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改 克隆要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆。git clone git@github.com:michaelliao/gitskills.gitGit支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。 分支查看分支：git branch创建分支：git branch 切换分支：git checkout 创建+切换分支：git checkout -b 合并某分支到当前分支：git merge 删除分支：git branch -d 冲突 合并当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。用git log –graph命令可以看到分支合并图。 Git分支十分强大，在团队开发中应该充分应用。合并分支时，加上–no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。 git stash修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。 开发一个新feature，最好新建一个分支；如果要丢弃一个没有被合并过的分支，可以通过git branch -D 强行删除。 查看远程库信息，使用git remote -v；本地新建的分支如果不推送到远程，对其他人就是不可见从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；建立本地分支和远程分支的关联，使用git branch –set-upstream branch-name origin/branch-name；从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。 我的git使用git client端需要在～/.ssh/config文件中添加如下信息：host 192.168.8.253port 61112 自己新建一个目录在该目录下git clone git@192.168.8.253:yprobe-c.git 切到目标目录下[heweiwei@heweiwei work]$ lsyprobe-c[heweiwei@heweiwei work]$ cd yprobe-c/ 查看处于那个分支[heweiwei@heweiwei yprobe-c]$ git branch masterremotes/origin/HEAD -&gt; origin/masterremotes/origin/enterpriseremotes/origin/master [heweiwei@heweiwei yprobe-c]$ 切换分支[heweiwei@heweiwei yprobe-c]$ git checkout enterprise /Branch enterprise set up to track remote branch enterprise from origin. Switched to a new branch ‘enterprise’[heweiwei@heweiwei yprobe-c]$[heweiwei@heweiwei yprobe-c]$ 查看远程所有分支[heweiwei@heweiwei yprobe-c]$ git branch -a enterprisemaster 查看状态[heweiwei@heweiwei yprobe-c]$ git statusOn branch enterprise 接收数据[heweiwei@heweiwei yprobe-c]$ git pullremote: Counting objects: 7, done.remote: Compressing objects: 100% (3/3), done.remote: Total 4 (delta 2), reused 0 (delta 0)Unpacking objects: 100% (4/4), done.From 192.168.8.253:yprobe-c ccf10bf..9b609d8 enterprise -&gt; origin/enterpriseUpdating ccf10bf..9b609d8Fast-forward dial_cpp/Dial_server.cpp | 88 ++++++++++++++++++++++++++++++++++++++++++++- 1 files changed, 86 insertions(+), 2 deletions(-) 保存现场git stash 修改了东西 暂存起来 我的提交：[heweiwei@heweiwei dial]$ git add Dial_epoll.cpp[heweiwei@heweiwei yprobe-c]$ git commit -m “repeat assignment”[heweiwei@heweiwei yprobe-c]$ git push[heweiwei@heweiwei yprobe-c]$ git logcommit 13fb4c131309358ce0099295f3a34a3e0a873f6eAuthor: heweiwei &#104;&#101;&#119;&#101;&#x69;&#x77;&#x65;&#105;&#x40;&#x68;&#101;&#x77;&#x65;&#105;&#x77;&#x65;&#105;&#46;&#40;&#x6e;&#x6f;&#110;&#x65;&#41;Date: Wed Mar 29 10:41:12 2017 +0800 repeat assignment 创建分支并切换到该分支[heweiwei@heweiwei yprobe-c]$ git checkout -b heweiwei_dial此命令相当于 git branch heweiwei_dial git checkout heweiwei_dial 把本地分支推送到远程分支[heweiwei@heweiwei yprobe-c]$ git push origin heweiwei_dial 删除远程分支git push origin :heweiwei_dial 注意origin后面的空格 （只有合并之后）才可以用此命令删除本地分支（因为创建本地分支的目的就是为了开发合并）[heweiwei@heweiwei yprobe-c]$ git branch -d heweiwei_dialerror: The branch ‘heweiwei_dial’ is not fully merged.If you are sure you want to delete it, run ‘git branch -D heweiwei_dial’. 强制删除本地分支（没有合并的分支也删除）[heweiwei@heweiwei yprobe-c]$ git branch -D heweiwei_dial 合并分支 用 git merge 命令来进行合并[heweiwei@heweiwei yprobe-c]$ git add edns_dial-1.1.1.8/*[heweiwei@heweiwei yprobe-c]$ git commit -m “edns_dial-1.1.1.8 have three log”[heweiwei@heweiwei yprobe-c]$ git checkout enterprise[heweiwei@heweiwei yprobe-c]$ git merge heweiwei_dial[heweiwei@heweiwei yprobe-c]$ git branch -d heweiwei_dialDeleted branch heweiwei_dial (was 39dc1df).[heweiwei@heweiwei yprobe-c]$ git push // 推到远程服务器[heweiwei@heweiwei yprobe-c]$ git push origin master.dev // 推到远程服务器具体某个分支 回退到上一个版本[heweiwei@heweiwei yprobe-c]$ git reset –hard HEAD^HEAD is now at 1475127 打rpm包和集成服务自启动上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100 git log –pretty=oneline[heweiwei@heweiwei yprobe-c]$ git log –pretty=oneline147512720038d1a40776abae7d119565c36c4451 打rpm包和集成服务自启动9623de89e686da18311aa26312ad43be1eb07f91 反向代理的https方式拨测的指定端口改变635c41264d788acaae9530306611032fc7b74bfa Fix Makefile: libthrift.a (v-0.9.0)80126458120dd8c3499af945b45572b1117e7272 拨测频繁切换，thrift通信架构只要命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个append GPL的commit id是3628164…， 回退到你想回的版本[heweiwei@heweiwei dial_cpp]$ git reset –hard 1475127HEAD is now at 1475127 打rpm包和集成服务自启动HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset –hard commit_id。穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。 若要查看各个分支最后一个提交对象的信息，运行 git branch -v： 将远程版本库回滚到上一个版本 或者回滚到以前某个版本 git reset –hard HEAD^ 或者 git reset –hard “commit ID”git push origin master -f git clone git@192.168.8.253:yrdns.git 递归代码git clone ssh://git@192.168.8.253:61112/clib.git clib库增加了授权功能[heweiwei@heweiwei yrdnsl]$ git pull origin master.devFrom 192.168.8.253:yrdns branch master.dev -&gt; FETCH_HEADUpdating 536db80..83eafe8Fast-forward.gitignore | 3 +Makefile.in.temp | 1 +conf/yrdns.conf | 21 +-include/yr_cache.h | 4 +-include/yr_config.h | 92 ++-include/yr_hash.h | 1 +include/yr_ini.h | 2 +-include/yr_job.h | 1 +include/yr_log.h | 4 +include/yr_packet.h | 2 +include/yr_recursing.h | 2 +include/yr_stat.h | 5 +include/zone.h | 528 +++++++src/Makefile | 2 +-src/yr_cache.c | 121 +-src/yr_config.c | 1281 ++++++++++++++++-src/yr_forwarder.c | 2 +-src/yr_hash.c | 9 +-src/yr_iphash.c | 3 +-src/yr_iterator.c | 117 +-src/yr_job.c | 232 ++–src/yr_log.c | 111 ++-src/yr_recursing.c | 54 +-src/yr_thrift.c | 10 +-src/yr_view.c | 4 +-src/zone.c | 3747 ++++++++++++++++++++++++++++++++++++++++++++++++version | 2 +-27 files changed, 6049 insertions(+), 312 deletions(-)create mode 100644 include/zone.hcreate mode 100644 src/zone.c]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux内核之list.h]]></title>
    <url>%2F2017%2F09%2F14%2Flinux%E5%86%85%E6%A0%B8%E4%B9%8Blist-h%2F</url>
    <content type="text"><![CDATA[大而全参考地址非常详细 内核中经常采用链表来管理对象，先看一下内核中对链表的定义struct list_head { struct list_head next, prev;}; 一般将该数据结构嵌入到其他的数据结构中，从而使得内核可以通过链表的方式管理新的数据结构，看一个例子:struct example { member a; struct list_head list; member b;}; 1、链表的定义和初始化您可以通过两种方式来定义和初始化一个链表头结点，例如，您想定义一个链表头结点mylist，那么您可以这么做：① LIST_HEAD(mylist); // 使用LIST_HEAD宏定义并初始化一个链表也可以这么做：② struct list_head mylist; // 定义一个链表INIT_LIST_HEAD(&amp;mylist); // 使用INIT_LIST_HEAD函数初始化链表 可以看出方式①稍微简单一点，我们先来分析一下LIST_HEAD宏： #define LIST_HEAD_INIT(name) { &amp;(name), &amp;(name) } #define LIST_HEAD(name) /struct list_head name = LIST_HEAD_INIT(name) 很容易看出LIST_HEAD(mylist);会被扩展为：struct list_head mylist = { &amp;(mylist), &amp;(mylist) }; list_head结构只有两个成员：next和prev。从上面的代码可以看出，next和prev都被赋值为链表mylist的地址，也就是说，链表初始化后next和prev都是指向自己的。 大多数情况下，list_head是被嵌入到其他数据结构中的，比如上面的example结构里的list成员，那么如何对list成员进行初始化？通过调用INIT_LIST_HEAD函数：struct example test;INIT_LIST_HEAD(&amp;test.list);该函数简单地将list成员的prev和next指针指向自己。 可以看出链表结点在初始化时，都将prev和next指向自己。注意：对链表的初始化非常重要，因为如果使用一个未被初始化的链表结点，很有可能会导致内核异常。例如，在对一个链表结点调用list_del函数后，接着再去对该结点进行一些操作。后面会有分析的：） 2、对链表常用的操作对链表常用的操作无非就是增加、删除、遍历等。当然内核还提供很多其他的操作，如替换某个结点、将某个结点移动到链表尾端等等，这些操作都是通过调用基本的增加、删除等操作完成的。 ① 增加：list_add和list_add_tail调用list_add可以将一个新链表结点插入到一个已知结点的后面；调用list_add_tail可以将一个新链表结点插入到一个已知结点的前面； 下面分析它们的具体实现，它们都以不同的参数调用了相同的函数list_add：static inline void list_add(struct list_head new, struct list_head prev, struct list_head *next){ next-&gt;prev = new; new-&gt;next = next; new-&gt;prev = prev; prev-&gt;next = new;}该函数将new结点插入到prev结点和next之间； static inline void list_add(struct list_head new, struct list_head head){ list_add(new, head, head-&gt;next);}list_add函数中以new、head、head-&gt;next为参数调用list_add，将new结点插入到head和head-&gt;next之间，也就是将new结点插入到特定的已知结点head的后面； static inline void list_add_tail(struct list_head new, struct list_head head){ list_add(new, head-&gt;prev, head);}而list_add_tail函数则以new、head-&gt;prev、head为参数调用list_add，将new结点插入到head-&gt;prev和head之间，也就是将new结点插入到特定的已知结点head的前面。 有了list_add和list_add_tail，我们可以很方便地实现栈（list_add）和队列（list_add_tail），在本文的最后一节，我们再做详细的分析。 ② 删除：list_del和list_del_init调用list_del函数删除链表中的一个结点；调用list_del_init函数删除链表中的一个结点，并初始化被删除的结点（也就是使被删除的结点的prev和next都指向自己）； 下面分析它们的具体实现，它们都调用了相同的函数list_del：static inline void list_del(struct list_head prev, struct list_head next){ next-&gt;prev = prev; prev-&gt;next = next;}该函数实际的作用是让prev结点和next结点互相指向； static inline void list_del(struct list_head *entry){ list_del(entry-&gt;prev, entry-&gt;next); entry-&gt;next = LIST_POISON1; entry-&gt;prev = LIST_POISON2;}该函数中以entry-&gt;prev和entry-&gt;next为参数调用list_del函数，使得entry结点的前、后结点绕过entry直接互相指向，然后将entry结点的前后指针指向LIST_POISON1和LIST_POISON2，从而完成对entry结点的删除。此函数中的LIST_POISON1和LIST_POISON2有点让人费解，因为一般情况下我们删除entry后，应该让entry的prev和next指向NULL的，可是这里却不是，原因有待调查。 static inline void list_del_init(struct list_head *entry){ __list_del(entry-&gt;prev, entry-&gt;next); INIT_LIST_HEAD(entry);}与list_del不同，list_del_init将entry结点删除后，还会对entry结点做初始化，使得entry结点的prev和next都指向自己。 3、几个重要的宏内核提供了一组宏，以方便对链表进行管理，下面我只介绍到目前为止，我遇到过的，可能会很少，因为我接触到的很有限，以后遇到其他的会添加进来的。下面开始我们的分析啦:) ① list_entry前面说过，list_head结构通常被嵌入到其他数据结构中，以便内核可以通过链表的方式管理这些数据结构。假设这样一种场景：我们已知类型为example的对象的list成员的地址ptr（struct list_head *ptr），那么我们如何通过ptr来得到该example对象的地址呢？答案很明显，使用container_of宏。不过，在这样的情况下我们应该通过使用list_entry宏来完成container_of宏的功能，因为这样更容易理解一点。其实list_entry宏很简单：#define list_entry(ptr, type, member) container_of(ptr, type, member) ……上述情况，我们可以这样： list_entry(ptr, struct example, list); 来获取example对象的指针。 ② list_for_each_entry对链表的一个重要的操作就是对链表进行遍历，以达到某种应用目的，比如统计链表结点的个数等等。先来看看内核中对该宏的定义： #define list_for_each_entry(pos, head, member) /for (pos = list_entry((head)-&gt;next, typeof(pos), member); / prefetch(pos-&gt;member.next), &amp;pos-&gt;member != (head); / pos = list_entry(pos-&gt;member.next, typeof(pos), member)) 其中，pos是指向宿主结构的指针，在for循环中是一个迭代变量；head是要进行遍历的链表头指针；member是list_head成员在宿主结构中的名字。]]></content>
      <categories>
        <category>linux基础</category>
      </categories>
      <tags>
        <tag>list</tag>
        <tag>linux基础</tag>
        <tag>链表基础操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux压缩命令]]></title>
    <url>%2F2017%2F09%2F12%2Flinux%E5%8E%8B%E7%BC%A9%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[举例[root@www ~]# tar [-j|-z] [cv] [-f 创建的档名] filename… &lt;==打包与压缩[root@www ~]# tar [-j|-z] [tv] [-f 创建的档名] &lt;==察看档名[root@www ~]# tar [-j|-z] [xv] [-f 创建的档名] [-C 目录] &lt;==解压缩 选项与参数：-c ：创建打包文件，可搭配 -v 来察看过程中被打包的档名(filename)-t ：察看打包文件的内容含有哪些档名，重点在察看『档名』就是了；-x ：解打包或解压缩的功能，可以搭配 -C (大写) 在特定目录解开 特别留意的是， -c, -t, -x 不可同时出现在一串命令列中。-j ：透过 bzip2 的支持进行压缩/解压缩：此时档名最好为 .tar.bz2-z ：透过 gzip 的支持进行压缩/解压缩：此时档名最好为 .tar.gz-v ：在压缩/解压缩的过程中，将正在处理的档名显示出来！-f filename：-f 后面要立刻接要被处理的档名！建议 -f 单独写一个选项罗！-C 目录 ：这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项。 其他后续练习会使用到的选项介绍：-p ：保留备份数据的原本权限与属性，常用於备份(-c)重要的配置档-P ：保留绝对路径，亦即允许备份数据中含有根目录存在之意；–exclude=FILE：在压缩的过程中，不要将 FILE 打包！ 其实最简单的使用 tar 就只要记忆底下的方式即可： ● 压 缩：tar -jcv -f filename.tar.bz2 要被压缩的文件或目录名称 ● 查 询：tar -jtv -f filename.tar.bz2 ● 解压缩：tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录 ● 压 缩：tar -zcvf .tar.gz dir/file ● 解压缩 ：tar -zxvf .tar.gz 压缩中的战斗机xzxz这个压缩可能很多都很陌生，不过您可知道xz是绝大数linux默认就带的一个压缩工具。之前xz使用一直很少，所以几乎没有什么提起。我是在下载phpmyadmin的时候看到这种压缩格式的，phpmyadmin压缩包xz格式的居然比7z还要小，这引起我的兴趣。最新一段时间会经常听到xz被采用的声音，像是最新的archlinux某些东西就使用xz压缩。不过xz也有一个坏处就是压缩时间比较长，比7z压缩时间还长一些。不过压缩是一次性的，所以可以忽略。xz压缩文件方法或命令xz -z 要压缩的文件如果要保留被压缩的文件加上参数 -k ，如果要设置压缩率加入参数 -0 到 -9调节压缩率。如果不设置，默认压缩等级是6.xz解压文件方法或命令xz -d 要解压的文件同样使用 -k 参数来保留被解压缩的文件。创建或解压tar.xz文件的方法习惯了 tar czvf 或 tar xzvf 的人可能碰到 tar.xz也会想用单一命令搞定解压或压缩。其实不行 tar里面没有征对xz格式的参数比如 z是针对 gzip，j是针对 bzip2。创建tar.xz文件：只要先 tar cvf xxx.tar xxx/ 这样创建xxx.tar文件先，然后使用 xz -z xxx.tar 来将 xxx.tar压缩成为 xxx.tar.xz 更多压缩详解参考地址更多举例01-.tar格式解包：[＊＊＊＊＊＊＊]$ tar xvf FileName.tar打包：[＊＊＊＊＊＊＊]$ tar cvf FileName.tar DirName（注：tar是打包，不是压缩！） 02-.gz格式解压1：[＊＊＊＊＊＊＊]$ gunzip FileName.gz解压2：[＊＊＊＊＊＊＊]$ gzip -d FileName.gz压 缩：[＊＊＊＊＊＊＊]$ gzip FileName 03-.tar.gz格式解压：[＊＊＊＊＊＊＊]$ tar zxvf FileName.tar.gz压缩：[＊＊＊＊＊＊＊]$ tar zcvf FileName.tar.gz DirName 04-.bz2格式解压1：[＊＊＊＊＊＊＊]$ bzip2 -d FileName.bz2解压2：[＊＊＊＊＊＊＊]$ bunzip2 FileName.bz2压 缩： [＊＊＊＊＊＊＊]$ bzip2 -z FileName 05-.tar.bz2格式解压：[＊＊＊＊＊＊＊]$ tar jxvf FileName.tar.bz2压缩：[＊＊＊＊＊＊＊]$ tar jcvf FileName.tar.bz2 DirName 06-.bz格式解压1：[＊＊＊＊＊＊＊]$ bzip2 -d FileName.bz解压2：[＊＊＊＊＊＊＊]$ bunzip2 FileName.bz 07-.tar.bz格式解压：[＊＊＊＊＊＊＊]$ tar jxvf FileName.tar.bz 08-.Z格式解压：[＊＊＊＊＊＊＊]$ uncompress FileName.Z压缩：[＊＊＊＊＊＊＊]$ compress FileName 09-.tar.Z格式解压：[＊＊＊＊＊＊＊]$ tar Zxvf FileName.tar.Z压缩：[＊＊＊＊＊＊＊]$ tar Zcvf FileName.tar.Z DirName 10-.tgz格式解压：[＊＊＊＊＊＊＊]$ tar zxvf FileName.tgz 11-.tar.tgz格式解压：[＊＊＊＊＊＊＊]$ tar zxvf FileName.tar.tgz压缩：[＊＊＊＊＊＊＊]$ tar zcvf FileName.tar.tgz FileName 12-.zip格式解压：[＊＊＊＊＊＊＊]$ unzip FileName.zip压缩：[＊＊＊＊＊＊＊]$ zip FileName.zip DirName 13-.lha格式解压：[＊＊＊＊＊＊＊]$ lha -e FileName.lha压缩：[＊＊＊＊＊＊＊]$ lha -a FileName.lha FileName 14-.rar格式解压：[＊＊＊＊＊＊＊]$ rar a FileName.rar压缩：[＊＊＊＊＊＊＊]$ rar e FileName.rar 15-.tar.xz格式打包：[＊＊＊＊＊＊＊]$ tar -cvf FileName.tar DirName（注：tar是打包，不是压缩！）压缩：[＊＊＊＊＊＊＊]$ xz -z -9 FileName.tar （-0 到 -9 压缩率 默认-6其实变化不是很大） 解压：[＊＊＊＊＊＊＊]$ xz -d FileName.tar.xz解包：[＊＊＊＊＊＊＊]$ tar -xvf FileName.tar 总结常用的压缩格式 tar.gz tar.bz2 bz2能比gz强那么一丢丢，但相差不是很大压缩king tar.xz 压缩大小几乎是上面两个的一半 很强 但是压缩速度很慢 有利有弊吧 测试对比如下 具体实际情况灵活运用即可[root@localhost others]# du -sh *49M dhcp15M dhcp.tar.bz216M dhcp.tar.gz8.0M dhcp.tar.xz]]></content>
      <categories>
        <category>linux命令</category>
      </categories>
      <tags>
        <tag>压缩</tag>
        <tag>tar</tag>
        <tag>gzip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cetos6.8mysql安装]]></title>
    <url>%2F2017%2F09%2F11%2Fcetos6-8mysql%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[一，wget http://dev.mysql.com/get/mysql57-community-release-el6-8.noarch.rpm 二，yum localinstall mysql57-community-release-el6-8.noarch.rpm 三，yum install mysql-server 四，mysqld –initialize –user=mysql 五，找到密码 vi /var/log/mysqld.log 末尾localhost：后面就是临时密码 六，启动mysql服务 service mysqld start 七，修改密码 mysqladmin -uroot -p password 输入临时密码或复制也可以，设置新密码 八，chkconfig mysqld on 此步骤可做可不做 九，mysql -u root -p 输入密码启动]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装python3.5]]></title>
    <url>%2F2017%2F09%2F11%2F%E5%AE%89%E8%A3%85python3-5%2F</url>
    <content type="text"><![CDATA[安装python3.5可能使用的依赖[root@heweiwei heweiwei]# yum install openssl-devel bzip2-devel expat-devel gdbm-devel readline-devel sqlite-devel 到python官网找到下载路径, 用wget下载[root@heweiwei heweiwei]# wget https://www.python.org/ftp/python/3.5.1/Python-3.5.1.tgz 解压tgz包[root@heweiwei heweiwei]# tar -zxvf Python-3.5.1.tgz 把python移到/usr/local下面[root@heweiwei heweiwei]# mv Python-3.5.1 /usr/local 删除旧版本的python依赖[root@heweiwei heweiwei]# ll /usr/bin | grep python-rwxr-xr-x. 1 root root 20152 May 12 2016 abrt-action-analyze-python-rwxr-xr-x. 2 root root 9032 Aug 18 2016 pythonlrwxrwxrwx. 1 root root 6 Feb 27 16:05 python2 -&gt; python-rwxr-xr-x. 2 root root 9032 Aug 18 2016 python2.6-rwxr-xr-x. 1 root root 1418 Aug 18 2016 python2.6-configlrwxrwxrwx. 1 root root 16 Feb 28 17:21 python-config -&gt; python2.6-config [root@heweiwei heweiwei]# rm -rf /usr/bin/python 进入python目录[root@heweiwei heweiwei]# cd /usr/local/Python-3.5.1/[root@heweiwei Python-3.5.1]# 配置[root@heweiwei Python-3.5.1]# ./configure 编译 make[root@heweiwei Python-3.5.1]# make 编译，安装[root@heweiwei Python-3.5.1]# make install 删除旧的软链接，创建新的软链接到最新的python[root@heweiwei Python-3.5.1]# rm -rf /usr/bin/python[root@heweiwei Python-3.5.1]# ln -s /usr/local/bin/python3.5 /usr/bin/python 查看版本[heweiwei@heweiwei ~]$ python -VPython 3.5.1]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rpm包制作]]></title>
    <url>%2F2017%2F09%2F11%2Frpm%E5%8C%85%E5%88%B6%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[rpm 即软件包管理关键点：SPEC文档 生成工作目录：[root@localhost heweiwei]# yum install rpmdevtools[heweiwei@localhost ~]$ rpmdev-setuptree 此命令用来生成 rpmbuild 目录[heweiwei@localhost ~]$ ls rpmbuild/BUILD RPMS SOURCES SPECS SRPMS 目录分配：SOURCES放置打包资源，包括源码打包文件和补丁文件等；SPECS目录放置SPEC文档；BUILD打包过程中的工作目录；RPMS目录存放生成的二进制包，RPM包根据硬件平台不同分类，i386表示生成i386结构的包将存放在该目录下;SRPMS目录存放生成的源码包。 撰写SPEC文档 （最为核心）SPEC文档包括了 rpm打包过程的操作内容和新生成rpm包的基本信息等 它的作用对象是打包程序 rpmbuildSPEC文档编写参考模板文件然后一步步扩展 生成rpm包的源代码、shell脚本、配置文件都拷贝到SOURCES目录里，注意通常情况下源码的压缩格式都为*.tar.gz格式然后，将最最最重要的SPEC文件，命名格式一般是“软件名-版本.spec”的形式，将其拷贝到SPECS目录，切换到该目录下执行rpmbuild -ba 软件名-版本.spec-ba表示build all，即生成包括二进制包和源代码包的所有RPM包，如果正常的话，rpmbuild将正常退出，同时在RPMS目录和SRPMS目录中将生成对应的RPM包。 关键就是SPEC文件的写法，我们可以用rpmdev-newspec -o Name-version.spec命令来生成SPEC文件的模板，然后在上面修改即可 创建 安装 卸载rpmbuild -bb edns_dial.spec 创建rpm包rpm -qlp /root/rpmbuild/RPMS/x86_64/edns_dial-1.1.1.5-1.el6.x86_64.rpm 查看安装情况rpm -ivh edns_dial-1.1.1.5-1.el6.x86_64.rpm 安装rpm -ivh edns_dial-1.1.1.5-1.el6.x86_64.rpm –force（发生冲突强制执行）rpm -e ends_dial 卸载 特殊情况出现此情况libcrypto.so.10()(64bit) is needed by edns_dial-1.1.1.5-1.el6.x86_64file /usr/bin/edns_dial from install of edns_dial-1.1.1.5-1.el6.x86_64 conflictswith file from package dnsys-3.1.1.368-ydns_743863.x86_64用此命令rpm -ivh edns_dial-1.1.1.5-1.el6.x86_64.rpm –nodeps –force rpm包安装后的可执行程序一般为release版本若想要保留调试信息则应该在spec文件加入以下信息调试信息的作用不大，一般自动删除调试信息 %define debug_package %{nil}%define __strip /bin/true [root@localhost BUILD]# rpm -ivh /root/rpmbuild/RPMS/x86_64/edns_dial-1.1.1.7-1.el6.x86_64.rpmPreparing… ########################################### [100%]1:edns_dial ########################################### [100%][root@localhost BUILD]# md5sum edns_dial-1.1.1.7/edns_dialf569fa864f820a4a0dc3d30f057ca4e5 edns_dial-1.1.1.7/edns_dial[root@localhost BUILD]# md5sum /usr/bin/edns_dialf569fa864f820a4a0dc3d30f057ca4e5 /usr/bin/edns_dial[root@localhost BUILD]# rpm -e edns_dial[root@localhost BUILD]#对比后md5值一模一样 卸载出现此情况解决方案[root@localhost heweiwei]# rpm -e edns_dialerror: “edns_dial” specifies multiple packages:edns_dial-1.1.1.5-enterprise.el6.x86_64edns_dial-1.1.1.5-1.el6.x86_64[root@localhost heweiwei]# rpm -e edns_dial –allmatchesedns_dial-1.1.1.5-enterprise.el6.x86_64 edns_dial-1.1.1.5-1.el6.x86_64 rpmbuild –showrc | grep topdir 查看系统默认的工作车间自定义目录（车间）vi ~/.rpmmacros%_topdir /home/heweiwei/rpmbuild ##目录可以自定义mkdir ~/rpmbuildcd ~/rpmbuildmkdir -pv {BUILD,BUILDROOT,RPMS,SOURCES,SPECS,SRPMS} rpm -qi edns_dial 查看 rpm 包安装程序的详细信息]]></content>
      <categories>
        <category>linux基础</category>
      </categories>
      <tags>
        <tag>rpm</tag>
        <tag>打包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bind-9.11.2源码安装配置]]></title>
    <url>%2F2017%2F09%2F07%2Fbind-9-11-2%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[安装资源apt yum 均可 安装bind 但这里不做介绍，本文主要介源码安装源码下载地址选择比较稳定的版本进行下载本文用的是最新版本bind-9.11.2 解压tar -zxvf bind-9.11.2.tar.gz 配置./configure –prefix=/usr/local/bind9 –enable-threads –enable-static –enable-ipv6=yes 安装make &amp;&amp; make install 安装结束之后 建立目录结构cd /usr/local/bind9/mkdir var/namedmkdir /usr/local/bind9/var/logstouch var/run/named.pidtouch var/named_dump.dbtouch var/run/named.stats 获取最新的根配置cd var/namedwget ftp://ftp.rs.internic.net/domain/named.rootmv named.root named.ca 配置主配置文件cd /usr/local/bind9/etc/ 具体配置参考百度文库 named.conf options { directory &quot;/usr/local/bind9/var/named&quot;; pid-file &quot;/usr/local/bind9/var/run/named.pid&quot;; dump-file &quot;/usr/local/bind9/var/named_dump.db&quot;; statistics-file &quot;/usr/local/bind9/var/run/named.stats&quot;; }; // Log logging { channel error_log { file &quot;/usr/local/bind9/var/logs/error.log&quot; versions 10 size 32m; severity warning; print-time yes; print-severity yes; print-category yes; }; channel query_log { file &quot;/usr/local/bind9/var/logs/query.log&quot; versions 10 size 32m; severity info; print-time yes; print-severity yes; print-category yes; }; category default { error_log; }; category queries { query_log; }; }; // RNDC key “rndc-key” { algorithm hmac-md5; secret “D1rQg6l6lLExdxGMlJOEuA==”;}; controls { inet 127.0.0.1 port 953 allow { 127.0.0.1; } keys { “rndc-key”; };}; // Cacheing Only Name Server Config zone “.” IN { type hint; file &quot;named.ca&quot;; }; // localhost. zone “localhost” IN { type master; file &quot;localhost.zone&quot;; allow-update { none; }; }; zone “0.0.127.in-addr.arpa” IN { type master; file &quot;localhost.rzone&quot;; allow-update { none; }; }; // abc.com. zone “abc.com” IN { type master; file &quot;abc.com.zone&quot;; allow-update { none; }; }; zone “0.0.10.in-addr.arpa” IN { type master; file &quot;abc.com.rzone&quot;; allow-update { none; }; }; named.ca; This file holds the information on root name servers needed to; initialize cache of Internet domain name servers; (e.g. reference this file in the “cache . “; configuration file of BIND domain name servers).;; This file is made available by InterNIC; under anonymous FTP as; file /domain/named.cache; on server FTP.INTERNIC.NET; -OR- RS.INTERNIC.NET;; last update: August 29, 2017; related version of root zone: 2017082901;; FORMERLY NS.INTERNIC.NET;. 3600000 NS A.ROOT-SERVERS.NET.A.ROOT-SERVERS.NET. 3600000 A 198.41.0.4A.ROOT-SERVERS.NET. 3600000 AAAA 2001:503:ba3e::2:30;; FORMERLY NS1.ISI.EDU;. 3600000 NS B.ROOT-SERVERS.NET.B.ROOT-SERVERS.NET. 3600000 A 192.228.79.201B.ROOT-SERVERS.NET. 3600000 AAAA 2001:500:200::b;; FORMERLY C.PSI.NET;. 3600000 NS C.ROOT-SERVERS.NET.C.ROOT-SERVERS.NET. 3600000 A 192.33.4.12C.ROOT-SERVERS.NET. 3600000 AAAA 2001:500:2::c;; FORMERLY TERP.UMD.EDU;. 3600000 NS D.ROOT-SERVERS.NET.D.ROOT-SERVERS.NET. 3600000 A 199.7.91.13D.ROOT-SERVERS.NET. 3600000 AAAA 2001:500:2d::d;; FORMERLY NS.NASA.GOV;. 3600000 NS E.ROOT-SERVERS.NET.E.ROOT-SERVERS.NET. 3600000 A 192.203.230.10E.ROOT-SERVERS.NET. 3600000 AAAA 2001:500:a8::e;; FORMERLY NS.ISC.ORG;. 3600000 NS F.ROOT-SERVERS.NET.F.ROOT-SERVERS.NET. 3600000 A 192.5.5.241F.ROOT-SERVERS.NET. 3600000 AAAA 2001:500:2f::f;; FORMERLY NS.NIC.DDN.MIL;. 3600000 NS G.ROOT-SERVERS.NET.G.ROOT-SERVERS.NET. 3600000 A 192.112.36.4G.ROOT-SERVERS.NET. 3600000 AAAA 2001:500:12::d0d;; FORMERLY AOS.ARL.ARMY.MIL;. 3600000 NS H.ROOT-SERVERS.NET.H.ROOT-SERVERS.NET. 3600000 A 198.97.190.53H.ROOT-SERVERS.NET. 3600000 AAAA 2001:500:1::53;; FORMERLY NIC.NORDU.NET;. 3600000 NS I.ROOT-SERVERS.NET.I.ROOT-SERVERS.NET. 3600000 A 192.36.148.17I.ROOT-SERVERS.NET. 3600000 AAAA 2001:7fe::53;; OPERATED BY VERISIGN, INC.;. 3600000 NS J.ROOT-SERVERS.NET.J.ROOT-SERVERS.NET. 3600000 A 192.58.128.30J.ROOT-SERVERS.NET. 3600000 AAAA 2001:503:c27::2:30;; OPERATED BY RIPE NCC;. 3600000 NS K.ROOT-SERVERS.NET.K.ROOT-SERVERS.NET. 3600000 A 193.0.14.129K.ROOT-SERVERS.NET. 3600000 AAAA 2001:7fd::1;; OPERATED BY ICANN;. 3600000 NS L.ROOT-SERVERS.NET.L.ROOT-SERVERS.NET. 3600000 A 199.7.83.42L.ROOT-SERVERS.NET. 3600000 AAAA 2001:500:9f::42;; OPERATED BY WIDE;. 3600000 NS M.ROOT-SERVERS.NET.M.ROOT-SERVERS.NET. 3600000 A 202.12.27.33M.ROOT-SERVERS.NET. 3600000 AAAA 2001:dc3::35; End of file localhost.zone$TTL 86400 $ORIGIN localhost. @ IN SOA localhost. root.localhost. ( 2006083100 Serial (YYMMDDSN) 1800 Refresh 300 Retry 3600 Expiry 300 ) Minimum @ IN NS localhost. @ IN A 127.0.0.1 localhost.rzone $TTL 86400 @ IN SOA localhost. root.localhost. ( 2006083100 Serial (YYMMDDSN) 30M Refresh 5M Retry 1H Expire 5M ) Minimum @ IN NS localhost. 1 IN PTR localhost abc.com.zone$TTL 600 $ORIGIN abc.net. @ IN SOA abc.net. webmaster.abc.com. ( 2006083100 Serial (YYMMDDSN) 1800 Refresh 300 Retry 3600 Expiry 300 ) Minimum @ IN NS ns1.abc.com. @ IN A 10.0.0.97 ns1 IN A 10.0.0.97 www IN A 10.0.0.97 web IN CNAME www mail IN MX 10.0.0.97 abc.com.rzone$TTL 86400 @ IN SOA localhost. root.localhost. ( 2006083100 Serial (YYMMDDSN) 30M Refresh 5M Retry 1H Expire 5M ) Minimum @ IN NS localhost. 1 IN PTR localhost 启动/usr/local/bind9/sbin/named -gc /usr/local/bind9/etc/named.conf带日志启动不带日志去掉 -g 参数 启动脚本vim /etc/rc.d/init.d/namedif [ id -u -ne 0 ]thenecho “ERROR:For bind to port 53,must run as root.”exit 1ficase “$1” in start)if [ -x /usr/local/bind9/sbin/named ]; then/usr/local/bind9/sbin/named -c /usr/local/bind9/etc/named.conf &amp;&amp; echo ‘start named [ok]’fi;; stop)kill cat /usr/local/bind9/var/run/named.pid &amp;&amp; echo ‘stop named [ok]’;;restart)echo “restart named”$0 stop$0 start;;*)echo “$0 start | stop | restart”;; esac 启动服务service named start设置为开机启动编辑文件 vim /etc/rc.d/rc.local 添加以下内容即可/etc/rc.d/init.d/named start参考文章 更改首选服务器为自己vim /etc/resolv.confnameserver 127.0.0.1 总结至此一个滑溜溜的DNS 服务器就配置好了 这只是冰山一角]]></content>
      <categories>
        <category>bind</category>
      </categories>
      <tags>
        <tag>DNS</tag>
        <tag>bind</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务器性能测试]]></title>
    <url>%2F2017%2F09%2F06%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[几个术语首先对吞吐量（）、QPS、并发数、响应时间（RT）几个概念一直比较模糊，也不知道哪些指标可以较好的衡量系统的性能。今天特意查了些资料做一些记录：首先看一些概念（来自百度百科） 1. 响应时间(RT)响应时间是指系统对请求作出响应的时间。直观上看，这个指标与人对软件性能的主观感受是非常一致的，因为它完整地记录了整个计算机系统处理请求的时间。由于一个系统通常会提供许多功能，而不同功能的处理逻辑也千差万别，因而不同功能的响应时间也不尽相同，甚至同一功能在不同输入数据的情况下响应时间也不相同。所以，在讨论一个系统的响应时间时，人们通常是指该系统所有功能的平均时间或者所有功能的最大响应时间。当然，往往也需要对每个或每组功能讨论其平均响应时间和最大响应时间。对于单机的没有并发操作的应用系统而言，人们普遍认为响应时间是一个合理且准确的性能指标。需要指出的是，响应时间的绝对值并不能直接反映软件的性能的高低，软件性能的高低实际上取决于用户对该响应时间的接受程度。对于一个游戏软件来说，响应时间小于100毫秒应该是不错的，响应时间在1秒左右可能属于勉强可以接受，如果响应时间达到3秒就完全难以接受了。而对于编译系统来说，完整编译一个较大规模软件的源代码可能需要几十分钟甚至更长时间，但这些响应时间对于用户来说都是可以接受的。 2. 吞吐量(Throughput)吞吐量是指系统在单位时间内处理请求的数量。对于无并发的应用系统而言，吞吐量与响应时间成严格的反比关系，实际上此时吞吐量就是响应时间的倒数。前面已经说过，对于单用户的系统，响应时间或者系统响应时间和应用延迟时间,可以很好地度量系统的性能，但对于并发系统，通常需要用吞吐量作为性能指标。对于一个多用户的系统，如果只有一个用户使用时系统的平均响应时间是t，当有你n个用户使用时，每个用户看到的响应时间通常并不是n×t，而往往比n×t小很多（当然，在某些特殊情况下也可能比n×t大，甚至大很多）。这是因为处理每个请求需要用到很多资源，由于每个请求的处理过程中有许多不走难以并发执行，这导致在具体的一个时间点，所占资源往往并不多。也就是说在处理单个请求时，在每个时间点都可能有许多资源被闲置，当处理多个请求时，如果资源配置合理，每个用户看到的平均响应时间并不随用户数的增加而线性增加。实际上，不同系统的平均响应时间随用户数增加而增长的速度也不大相同，这也是采用吞吐量来度量并发系统的性能的主要原因。一般而言，吞吐量是一个比较通用的指标，两个具有不同用户数和用户使用模式的系统，如果其最大吞吐量基本一致，则可以判断两个系统的处理能力基本一致。 3. 并发用户数并发用户数是指系统可以同时承载的正常使用系统功能的用户的数量。与吞吐量相比，并发用户数是一个更直观但也更笼统的性能指标。实际上，并发用户数是一个非常不准确的指标，因为用户不同的使用模式会导致不同用户在单位时间发出不同数量的请求。一网站系统为例，假设用户只有注册后才能使用，但注册用户并不是每时每刻都在使用该网站，因此具体一个时刻只有部分注册用户同时在线，在线用户就在浏览网站时会花很多时间阅读网站上的信息，因而具体一个时刻只有部分在线用户同时向系统发出请求。这样，对于网站系统我们会有三个关于用户数的统计数字：注册用户数、在线用户数和同时发请求用户数。由于注册用户可能长时间不登陆网站，使用注册用户数作为性能指标会造成很大的误差。而在线用户数和同事发请求用户数都可以作为性能指标。相比而言，以在线用户作为性能指标更直观些，而以同时发请求用户数作为性能指标更准确些。 4. QPS每秒查询率(Query Per Second)每秒查询率QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准，在因特网上，作为域名系统服务器的机器的性能经常用每秒查询率来衡量。对应fetches/sec，即每秒的响应请求数，也即是最大吞吐能力。 从以上概念来看吞吐量和响应时间是衡量系统性能的重要指标，QPS虽然和吞吐量的计量单位不同，但应该是成正比的，任何一个指标都可以含量服务器的并行处理能力。当然Throughput更关心数据量，QPS更关心处理笔数。 QPS提升带来什么？QPS提升说明单台服务器处理能力提升，如果QPS提升1倍，服务器资源减少1半，或者说服务器不变可以支撑2倍的请求量。如何提升QPS？1）减少CPU的使用时间（哪些代码会消耗CPU：循环、字符串拼接\查找\替换、编码\解码、序列化\反序列化、压缩）2）增加CPU的数量3）减少同步锁（如果CPU不能被压到85%以上，并且此时的QPS已经达到了峰值，则说明另有瓶颈，接下去关注内存）RT提升带来什么？响应速度提升说明单词请求的处理速度提升，用户感觉任务处理速度更快，系统反应速度更快。当然在处理能力不变的情况下，RT的提升必然会提升QPS。如何提升RT？1）减少I/O的响应时间2）减少I/O的调用次数3）减少CPU使用时间（当然在I/O占大头的应用里，这方面优化效果肯定不明显）PV=page view 访问量 浏览量TPS=transactions per second 每秒事务数QPS=queries per second 每秒查询数 每秒可以处理多少查询RPS=requests per second 每秒处理的请求数RPS=并发数/平均响应时间 一．系统吞度量要素：一个系统的吞度量（承压能力）与request对CPU的消耗、外部接口、IO等等紧密关联。单个reqeust 对CPU消耗越高，外部系统接口、IO影响速度越慢，系统吞吐能力越低，反之越高。系统吞吐量几个重要参数：QPS（TPS）、并发数、响应时间QPS（TPS）：每秒钟request/事务 数量并发数： 系统同时处理的request/事务数响应时间： 一般取平均响应时间（很多人经常会把并发数和TPS理解混淆）理解了上面三个要素的意义之后，就能推算出它们之间的关系：QPS（TPS）= 并发数/平均响应时间一个系统吞吐量通常由QPS（TPS）、并发数两个因素决定，每套系统这两个值都有一个相对极限值，在应用场景访问压力下，只要某一项达到系统最高值，系统的吞吐量就上不去了，如果压力继续增大，系统的吞吐量反而会下降，原因是系统超负荷工作，上下文切换、内存等等其它消耗导致系统性能下降。决定系统响应时间要素我们做项目要排计划，可以多人同时并发做多项任务，也可以一个人或者多个人串行工作，始终会有一条关键路径，这条路径就是项目的工期。系统一次调用的响应时间跟项目计划一样，也有一条关键路径，这个关键路径是就是系统影响时间；关键路径是有CPU运算、IO、外部系统响应等等组成。 二．系统吞吐量评估：我们在做系统设计的时候就需要考虑CPU运算、IO、外部系统响应因素造成的影响以及对系统性能的初步预估。而通常境况下，我们面对需求，我们评估出来的出来QPS、并发数之外，还有另外一个维度：日PV。通过观察系统的访问日志发现，在用户量很大的情况下，各个时间周期内的同一时间段的访问流量几乎一样。比如工作日的每天早上。只要能拿到日流量图和QPS我们就可以推算日流量。通常的技术方法： 找出系统的最高TPS和日PV，这两个要素有相对比较稳定的关系（除了放假、季节性因素影响之外） 通过压力测试或者经验预估，得出最高TPS，然后跟进1的关系，计算出系统最高的日吞吐量。B2B中文和淘宝面对的客户群不一样，这两个客户群的网络行为不应用，他们之间的TPS和PV关系比例也不一样。 A)淘宝淘宝流量图： 淘宝的TPS和PV之间的关系通常为 最高TPS：PV大约为 1 : 113600 （相当于按最高TPS访问11个小时，这个是商品详情的场景，不同的应用场景会有一些不同）B) B2B中文站B2B的TPS和PV之间的关系不同的系统不同的应用场景比例变化比较大，粗略估计在1 : 8个小时左右的关系（09年对offerdetail的流量分析数据）。旺铺和offerdetail这两个比例相差很大，可能是因为爬虫暂的比例较高的原因导致。在淘宝环境下，假设我们压力测试出的TPS为100，那么这个系统的日吞吐量=10011*3600=396万这个是在简单（单一url）的情况下，有些页面，一个页面有多个request，系统的实际吞吐量还要小。无论有无思考时间（T_think），测试所得的TPS值和并发虚拟用户数(U_concurrent)、Loadrunner读取的交易响应时间（T_response）之间有以下关系（稳定运行情况下）： TPS=U_concurrent / (T_response+T_think)。并发数、QPS、平均响应时间三者之间关系 来源：http://www.cnblogs.com/jackei/ 软件性能测试的基本概念和计算公式一、软件性能的关注点对一个软件做性能测试时需要关注那些性能呢？我们想想在软件设计、部署、使用、维护中一共有哪些角色的参与，然后再考虑这些角色各自关注的性能点是什么，作为一个软件性能测试工程师，我们又该关注什么？首先，开发软件的目的是为了让用户使用，我们先站在用户的角度分析一下，用户需要关注哪些性能。对于用户来说，当点击一个按钮、链接或发出一条指令开始，到系统把结果已用户感知的形式展现出来为止，这个过程所消耗的时间是用户对这个软件性能的直观印象。也就是我们所说的响应时间，当相应时间较小时，用户体验是很好的，当然用户体验的响应时间包括个人主观因素和客观响应时间，在设计软件时，我们就需要考虑到如何更好地结合这两部分达到用户最佳的体验。如：用户在大数据量查询时，我们可以将先提取出来的数据展示给用户，在用户看的过程中继续进行数据检索，这时用户并不知道我们后台在做什么。用户关注的是用户操作的相应时间。其次，我们站在管理员的角度考虑需要关注的性能点。1、 相应时间2、 服务器资源使用情况是否合理3、 应用服务器和数据库资源使用是否合理4、 系统能否实现扩展5、 系统最多支持多少用户访问、系统最大业务处理量是多少6、 系统性能可能存在的瓶颈在哪里7、 更换那些设备可以提高性能8、 系统能否支持7×24小时的业务访问再次，站在开发（设计）人员角度去考虑。1、 架构设计是否合理2、 数据库设计是否合理3、 代码是否存在性能方面的问题4、 系统中是否有不合理的内存使用方式5、 系统中是否存在不合理的线程同步方式6、 系统中是否存在不合理的资源竞争那么站在性能测试工程师的角度，我们要关注什么呢？一句话，我们要关注以上所有的性能点。 二、软件性能的几个主要术语1、响应时间：对请求作出响应所需要的时间网络传输时间：N1+N2+N3+N4应用服务器处理时间：A1+A3数据库服务器处理时间：A2响应时间=N1+N2+N3+N4+A1+A3+A22、并发用户数的计算公式系统用户数：系统额定的用户数量，如一个OA系统，可能使用该系统的用户总数是5000个，那么这个数量，就是系统用户数。同时在线用户数：在一定的时间范围内，最大的同时在线用户数量。同时在线用户数=每秒请求数RPS（吞吐量）+并发连接数+平均用户思考时间平均并发用户数的计算：C=nL / T其中C是平均的并发用户数，n是平均每天访问用户数（login session），L是一天内用户从登录到退出的平均时间（login session的平均时间），T是考察时间长度（一天内多长时间有用户使用系统）并发用户数峰值计算：C^约等于C + 3根号C其中C^是并发用户峰值，C是平均并发用户数，该公式遵循泊松分布理论。3、吞吐量的计算公式指单位时间内系统处理用户的请求数从业务角度看，吞吐量可以用：请求数/秒、页面数/秒、人数/天或处理业务数/小时等单位来衡量从网络角度看，吞吐量可以用：字节/秒来衡量对于交互式应用来说，吞吐量指标反映的是服务器承受的压力，他能够说明系统的负载能力以不同方式表达的吞吐量可以说明不同层次的问题，例如，以字节数/秒方式可以表示数要受网络基础设施、服务器架构、应用服务器制约等方面的瓶颈；已请求数/秒的方式表示主要是受应用服务器和应用代码的制约体现出的瓶颈。当没有遇到性能瓶颈的时候，吞吐量与虚拟用户数之间存在一定的联系，可以采用以下公式计算：F=VU R /其中F为吞吐量，VU表示虚拟用户个数，R表示每个虚拟用户发出的请求数，T表示性能测试所用的时间4、性能计数器是描述服务器或操作系统性能的一些数据指标，如使用内存数、进程时间，在性能测试中发挥着“监控和分析”的作用，尤其是在分析统统可扩展性、进行新能瓶颈定位时有着非常关键的作用。资源利用率：指系统各种资源的使用情况，如cpu占用率为68%，内存占用率为55%，一般使用“资源实际使用/总的资源可用量”形成资源利用率。5、思考时间的计算公式Think Time，从业务角度来看，这个时间指用户进行操作时每个请求之间的时间间隔，而在做新能测试时，为了模拟这样的时间间隔，引入了思考时间这个概念，来更加真实的模拟用户的操作。在吞吐量这个公式中F=VU R / T说明吞吐量F是VU数量、每个用户发出的请求数R和时间T的函数，而其中的R又可以用时间T和用户思考时间TS来计算：R = T / TS下面给出一个计算思考时间的一般步骤：A、首先计算出系统的并发用户数C=nL / T F=R×CB、统计出系统平均的吞吐量F=VU R / T R×C = VU R / TC、统计出平均每个用户发出的请求数量R=uC*T/VUD、根据公式计算出思考时间TS=T/R]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>DNS</tag>
        <tag>QPS</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有趣的linux命令]]></title>
    <url>%2F2017%2F09%2F05%2F%E6%9C%89%E8%B6%A3%E7%9A%84linux%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[fuck命令首先安装pip3 或者 pippip3 install thefuckeval $(thefuck –alias)source ~/.bashrc sl 命令sudo apt install slsl 会看到一辆火车从屏幕闪过 fortune命令sudo apt install fortunefortune cmatrix命令 矩阵效果sudo apt-get install cmatrixcmatrix cal命令打印日历 September 2017Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 910 11 12 13 14 15 1617 18 19 20 21 22 2324 25 26 27 28 29 30 figlet 、toilet命令 艺术字安装同上sudo apt-get install figletsudo apt-get install toiletfiglet i love youtoilet i love you shred 命令 搞破坏 哈哈哈比如把你私藏的种子文件搞乱 无法恢复哦 很炫酷。。。]]></content>
      <tags>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DNS BIND 压力测试 queryperf 使用]]></title>
    <url>%2F2017%2F09%2F05%2FDNS-BIND-%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95-queryperf-%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[引言首先queryperf是bind自带的压力测试软件，使用queryperf可以对DNS服务器作请求测试，操作简单明了易上手，可以多次测试取平均值，特别说明queryperf的测试结果不一定准确，但与实际情况接近，具有一定参考价值。 安装源码安装官网下载bind源码[heweiwei@heweiwei local]$ cd /usr/local/bind-9.11.1/contrib/queryperf[root@heweiwei queryperf]# ./configure[root@heweiwei queryperf]# cp queryperf /usr/bin/ 使用queryperf使用格式：queryperf [-d datafile] [-s server_addr] [-p port] [-q num_queries]-d: 后面接上一个文件，文件的内容是用户对DNS的请求，一行为一条请求，所以为了测试，我们可以在里面写上几千几万条。-s: DNS服务器地址-p: DNS服务器端口-q: 指定查询的输出的最大数量 编辑测试文件[heweiwei@heweiwei ~]$ vim test.txt比如把下面内容 当然这些内容少的可怜，测试可以加入上万条记录www.baidu.com Awww.baidu.cn cnameqq.com Asohu.com Apython.org CNAMEpython.org Aisc.org A163.com A163.com SOA163.com MX163.com ANY163.com CNAMEcsdn.net Awww.jd.com Awww.jd.com NS 执行[heweiwei@heweiwei ~]$ queryperf -d test.txt -s 192.168.6.189 出现下列结果DNS Query Performance Testing ToolVersion: $Id: queryperf.c,v 1.12 2007/09/05 07:36:04 marka Exp $ [Status] Processing input data[Status] Sending queries (beginning with 192.168.6.189)[Timeout] Query timed out: msg id 2[Timeout] Query timed out: msg id 4[Timeout] Query timed out: msg id 5[Timeout] Query timed out: msg id 8[Timeout] Query timed out: msg id 11[Timeout] Query timed out: msg id 14[Status] Testing complete Statistics: Parse input file: once Ended due to: reaching end of file Queries sent: 15 queries Queries completed: 15 queries Queries lost: 0 queries Queries delayed(?): 0 queries RTT max: 1.022373 sec RTT min: 0.015800 sec RTT average: 0.135892 sec RTT std deviation: 0.313435 sec RTT out of range: 0 queries Percentage completed: 100.00% Percentage lost: 0.00% Started at: Tue Sep 5 17:56:57 2017 Finished at: Tue Sep 5 17:57:02 2017 Ran for: 5.000256 seconds Queries per second: 2.999846 qps 总结1、在作服务器的性能测试时，最好不要在服务器平台自身使用测试软件测试，最好换另外一台机器，这样CPU处理的结果会更准确。2、测试时先预估平台会遇到的最大请求数，用这个请求数作测试，量力而为，因为如果服务器遇到大流量的DDOS，单一机器性能再好，也扛不住。3、使用queryperf作性能测试时，最好测试多次，取平均值。4、可以修改配置文件的部分参数测试，如，开启递归，开启查询日志等功能作测试。 特别感谢本文参考文章]]></content>
      <categories>
        <category>DNS服务</category>
      </categories>
      <tags>
        <tag>DNS</tag>
        <tag>BIND</tag>
        <tag>queryper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速入门shell脚本]]></title>
    <url>%2F2017%2F09%2F04%2F%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8shell%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[参考原文地址[快速入门shell脚本]http://c.biancheng.net/cpp/view/2736.html 变量 含义$0 当前脚本的文件名$n 传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2。$# 传递给脚本或函数的参数个数。$ 传递给脚本或函数的所有参数。$@ 传递给脚本或函数的所有参数。被双引号(“ “)包含时，与 $ 稍有不同，下面将会讲到。$? 上个命令的退出状态，或函数的返回值。$$ 当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。 $* 和 $@ 的区别$ 和 $@ 都表示传递给函数或脚本的所有参数，不被双引号(“ “)包含时，都以”$1” “$2” … “$n” 的形式输出所有参数。但是当它们被双引号(“ “)包含时，”$“ 会将所有的参数作为一个整体，以”$1 $2 … $n”的形式输出所有参数；“$@” 会将各个参数分开，以”$1” “$2” … “$n” 的形式输出所有参数。 算术运算符列表a = 10b = 20运算符 说明 举例 加法 expr $a + $b 结果为 30。 减法 expr $a - $b 结果为 -10。 乘法 expr $a \* $b 结果为 200。/ 除法 expr $b / $a 结果为 2。% 取余 expr $b % $a 结果为 0。= 赋值 a=$b 将把变量 b 的值赋给 a。== 相等。用于比较两个数字，相同则返回 true。 [ $a == $b ] 返回 false。!= 不相等。用于比较两个数字，不相同则返回 true。 [ $a != $b ] 返回 true。注意：条件表达式要放在方括号之间，并且要有空格，例如 [$a==$b] 是错误的，必须写成 [ $a == $b ]。 关系运算符列表运算符 说明 举例-eq 检测两个数是否相等，相等返回 true。 [ $a -eq $b ] 返回 true。-ne 检测两个数是否相等，不相等返回 true。 [ $a -ne $b ] 返回 true。-gt 检测左边的数是否大于右边的，如果是，则返回 true。 [ $a -gt $b ] 返回 false。-lt 检测左边的数是否小于右边的，如果是，则返回 true。 [ $a -lt $b ] 返回 true。-ge 检测左边的数是否大等于右边的，如果是，则返回 true。 [ $a -ge $b ] 返回 false。-le 检测左边的数是否小于等于右边的，如果是，则返回 true。 [ $a -le $b ] 返回 true。 布尔运算符列表运算符 说明 举例! 非运算，表达式为 true 则返回 false，否则返回 true。 [ ! false ] 返回 true。-o 或运算，有一个表达式为 true 则返回 true。 [ $a -lt 20 -o $b -gt 100 ] 返回 true。-a 与运算，两个表达式都为 true 才返回 true。 [ $a -lt 20 -a $b -gt 100 ] 返回 false。 字符串运算符列表运算符 说明 举例= 检测两个字符串是否相等，相等返回 true。 [ $a = $b ] 返回 false。!= 检测两个字符串是否相等，不相等返回 true。 [ $a != $b ] 返回 true。-z 检测字符串长度是否为0，为0返回 true。 [ -z $a ] 返回 false。-n 检测字符串长度是否为0，不为0返回 true。 [ -z $a ] 返回 true。str 检测字符串是否为空，不为空返回 true。 [ $a ] 返回 true。 文件测试运算符列表操作符 说明 举例-b file 检测文件是否是块设备文件，如果是，则返回 true。 [ -b $file ] 返回 false。-c file 检测文件是否是字符设备文件，如果是，则返回 true。 [ -b $file ] 返回 false。-d file 检测文件是否是目录，如果是，则返回 true。 [ -d $file ] 返回 false。-f file 检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。 [ -f $file ] 返回 true。-g file 检测文件是否设置了 SGID 位，如果是，则返回 true。 [ -g $file ] 返回 false。-k file 检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。 [ -k $file ] 返回 false。-p file 检测文件是否是具名管道，如果是，则返回 true。 [ -p $file ] 返回 false。-u file 检测文件是否设置了 SUID 位，如果是，则返回 true。 [ -u $file ] 返回 false。-r file 检测文件是否可读，如果是，则返回 true。 [ -r $file ] 返回 true。-w file 检测文件是否可写，如果是，则返回 true。 [ -w $file ] 返回 true。-x file 检测文件是否可执行，如果是，则返回 true。 [ -x $file ] 返回 true。-s file 检测文件是否为空（文件大小是否大于0），不为空返回 true。 [ -s $file ] 返回 true。-e file 检测文件（包括目录）是否存在，如果是，则返回 true。 [ -e $file ] 返回 true。 全部可用的重定向命令列表命令 说明command &gt; file 将输出重定向到 file。command &lt; file 将输入重定向到 file。command &gt;&gt; file 将输出以追加的方式重定向到 file。n &gt; file 将文件描述符为 n 的文件重定向到 file。n &gt;&gt; file 将文件描述符为 n 的文件以追加的方式重定向到 file。n &gt;&amp; m 将输出文件 m 和 n 合并。n &lt;&amp; m 将输入文件 m 和 n 合并。&lt;&lt; tag 将开始标记 tag 和结束标记 tag 之间的内容作为输入。]]></content>
      <categories>
        <category>linux基础</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>inux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[国漫推荐大讲堂]]></title>
    <url>%2F2017%2F09%2F03%2F%E5%9B%BD%E6%BC%AB%E6%8E%A8%E8%8D%90%E5%A4%A7%E8%AE%B2%E5%A0%82%2F</url>
    <content type="text"><![CDATA[动画制作公司比较出名的有玄机科技，虚拟印象，铸梦动画，若森数字。 玄机科技国内动漫制作佼佼者，坊间粉丝说玄机科技必属精品，目前我觉得大部分都不错唯独天逾 秦时明月作为一名骨灰级秦迷，见证了秦时明月每一步成长。 天行九歌擦写不动了…这…]]></content>
      <categories>
        <category>动漫</category>
      </categories>
      <tags>
        <tag>秦时明月</tag>
        <tag>墓王之王</tag>
        <tag>超神学院</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git远程仓库关联]]></title>
    <url>%2F2017%2F09%2F02%2Fgit%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E5%85%B3%E8%81%94%2F</url>
    <content type="text"><![CDATA[引言我的环境：ubantu17.04 其他linux发行版本安装使用大同小异安装git：sudo apt-get install git首先必须有一个githup账号 去官网注册即可 同时绑定邮箱有了账号后创建远程仓库 比如我创建的仓库名字为project 密钥本地创建密钥命令如下ssh-keygen -t rsa -C “邮箱地址”公钥存放在用户主目录 ~/.ssh/id_rsa.pub复制到官网在账户设置一栏添加即可 验证连接验证是否能连接上ssh -T git@github.com输入yes后出现类似以下内容表示已经可以连接Hi he475943497! You’ve successfully authenticated, but GitHub does not provide shell access. 创建本地仓库执行下列命令创建仓库并初始化mkdir projectcd projectgit init 指明用户若之前没有使用git执行以下操作git config –global user.email “邮箱地址”git config –global user.name “用户名” 本地与远程关联并推送touch test.txtgit add test.txtgit commit -m “test”git remote add origin git@github.com:用户名/仓库名.git推送到远程git push -u origin master 第一次提交加-u参数之后提交git add . git commit -m “test” git push 即可 git教程git作为目前最流行的版本管理工具，我觉得很有学习的必要有兴趣的同学可以参考：廖雪峰git教程作者写的很幽默通俗易懂]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux一些命令]]></title>
    <url>%2F2017%2F09%2F01%2Flinux%E4%B9%8Bdig%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[dig1.查看域名的A记录 dig yahoo.com2.查看域名的ip dig yahoo.com +short3.查看域名的MX 记录 dig yahoo.com MX4.查看域名的SOA记录 dig yahoo.com SOA5.查询域名的TTL记录 dig yahoo.com TTL6.查看内容信息 dig yahoo.com +nocomments +noquestion +noauthority +noadditional +nostats7.查询所有的DNS记录类型 dig yahoo.com ANY +noall +answer8.DNS反向查询 dig -x 72.30.38.140 +short9.查询多个DNS记录 dig yahoo.com mx +noall +answer redhat.com ns +noall +answer10.单独查询 dig yahoo.com A/SOA/MX/NS/PTR +noall +answer11.查询所有 dig yahoo.com ANY +noall +answer12.快速回答时，+short dig www.baidu.com AAAA +shor13.+multiline选项获得冗长的多行模式人性化注释的DSN的SOA记录，一般来说，用+multiline选项获得的信息可以显示很多，就像BIND配置文件一样,dig +nocmd baidu.com any +multiline +noall +answer14.跟踪dig的查询路径 dig v.qq.com +trace15.dig qq.com @x.x.x.x findLinux下find命令在目录结构中搜索文件，并执行指定的操作。Linux下find命令提供了相当多的查找条件find pathname -options [-print -exec -ok …] 用于在文件树种查找文件，并作出相应的处理find -atime -2 超找48小时内修改过的文件find . -name “.log” 在当前目录查找 以.log结尾的文件。 “. “代表当前目录find /opt/soft/test/ -perm 777 查找/opt/soft/test/目录下 权限为 777的文件find . -type f -name “.log” 查找当目录，以.log结尾的普通文件find . -type d | sort 查找当前所有目录并排序find . -size +1000c -print 查找当前目录大于1K的文件ubantu 用于16.04以上版本 ubantu 界面设置gsettings set com.canonical.Unity.Launcher launcher-position Bottom 移动到下方gsettings set com.canonical.Unity.Launcher launcher-position Left 移动到左方 vimvim打开一个文件 shift + ： 使用 vsplit 命令再打开一个文件 vsplit + 文件q qall（关闭所有） only（关闭当前）在一般模式下输入“:new /root/2.txt” 新编辑文件2.txtctrl + ww 切换 把正在编辑的文件另存为在一般模式下输入“:w /root/1.txt” 正在编辑文件时，不退出文件仍可以运行linux命令eg：在编辑模式下输入“:! cat /root/1.txt” .查找替换的功能使用例：在10到15行的行首增加“#”在一般模式下输入“:10,15s/^/#/”例：在10到15行的行首去掉“#”在一般模式下输入“:10,15s/^#//”例：在10到15行的行首增加“//”在一般模式下输入“:10,15s/^/\/\//”或者“:10,15s@^@//@”或者“:10,15s#^#//#” 把文件恢复到打开时的状态在一般模式下输入“:e! vim 中 shift + 3 选中单词 可以突出显示这个单词全部 ctrl +n 自动补全 ctrl + p 也一样 删除空行：:%s/^\n$//g 自动对齐 v 进入可视模式后选中要对齐的部分 = 号自动对齐 vim 用swap 文件恢复未保存的文件vim -r filename 后 删除 swap文件vimdiff比较两个文件不同vimdiff /home/heweiwei/dial_cpp/Makefile Makefile.jc或者使用diff命令重定向也可以达到比较效果diff /home/heweiwei/dial_cpp/Makefile Makefile.jc &gt; cmp.txt stat 文件 获取文件详细信息fdisk -l 查看磁盘信息 grep 命令查找指定进程ps -ef|grep svnps -aux|grep svnps -ef|grep svn -c 包含个数ps -ef|grep -c svn 输出test.txt文件中含有从test2.txt文件中读取出的关键词的内容行cat test.txt | grep -f test2.txtcat test.txt | grep -nf test2.txt 从文件中查找关键字grep ‘linux’ test.txtgrep ‘linux’ test.txt test2.txt grep不显示本身进程ps aux|grep [s]shps aux | grep ssh | grep -v “grep” 找出以 u 开头的行内容cat test.txt |grep ^u找出非 u 开头的行内容cat test.txt |grep ^[^u] 输出以hat结尾的行内容cat test.txt |grep hat$ 显示包含ed或者at字符的内容行cat test.txt |grep -E “ed|at” 显示当前目录下面以.txt 结尾的文件中的所有包含每个字符串至少有7个连续小写字符的字符串的行grep ‘[a-z]{7}‘ *.txt scp把本地文件或目录拷到目标机指定目录 对拷文件夹 (包括文件夹本身)scp -r /home/wwwroot/www/charts/util root@192.168.1.65:/home/wwwroot/limesurvey_back/scp /home/wwwroot/www/charts/util root@192.168.1.65:/home/wwwroot/limesurvey_back/scp 对拷文件夹下所有文件 (不包括文件夹本身)scp /home/wwwroot/www/charts/util/* root@192.168.1.65:/home/wwwroot/limesurvey_back/scp 对拷文件并重命名scp /home/wwwroot/www/charts/util/a.txt root@192.168.1.65:/home/wwwroot/limesurvey_back/scp/b.text 把目标机文件或者目录拷贝到本地指定目录scp -r root@192.168.6.240:/home/heweiwei/studytest /home/heweiwei/]]></content>
      <categories>
        <category>linux命令</category>
      </categories>
      <tags>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言面试]]></title>
    <url>%2F2017%2F09%2F01%2FC%E8%AF%AD%E8%A8%80%E9%9D%A2%E8%AF%95%2F</url>
    <content type="text"><![CDATA[引言曾经面试做过的一些面试题目 C/C++题目：1、比较字符串输出它们第一个不同字母的位置，大小写不敏感 // if(str1[i] == (str2[i] | 0x20))int cmpstr(const char str1,const char str2){ int i = 0; while(str1[i] != &apos;\0&apos; &amp;&amp; str2[i] != &apos;\0&apos;) { if(str1[i] == (str2[i] | 0x20)) { i++; continue; } return i+1; } return 0; } 2、判断一个数是不是回文数，数字 1234321。int judge(int num){ int temp1 = 0,temp2 = 0,temp3 = num; while(num) { temp1 = num % 10; temp2 = temp2 * 10 + temp1; num = num / 10; } if(temp2 == temp3) { return 1; } return 0; } 3、比较两字符串长短，并返回结果。int cmpstr(const char str1,const char str2){ int i = 0,j = 0; while(str1[i]) { i++; } while(str2[j]) { j++; } return i - j; } 4、给一个字符串，编程取其中一个特定的字符并输出，返回值 int / char* 字符的偏移量 或 地址int findch(const char* str,char ch){ int i = 0; while(str[i]) { if(ch == str[i]) { return i+1; } i++; } return 0; } 5、是比较两个英文字符串的不相同的字符的位置（忽略字母大小写）int cmpstr(const char str1,const char str2,int site[]){ int i = 0,j = 0; while(str1[i] != &apos;\0&apos; &amp;&amp; str2[i] != &apos;\0&apos;) { if(str1[i] == (str2[i] | 0x20)) { i++; continue; } site[j] = i + 1; j++; i++; } return j; } 6、主函数调用一函数如：检索出字符串中出现次数最多的那个字符，不考虑大小写，然后返回该字符。char findch(const char* str){ int i = 0,j = 0,ct1 = 0,ct2 = 0; char ch1 = ‘\0’,ch2 = ‘\0’; while(str[i]) { j = 0; ct1 = 0; //这两个条件不可忽略 while(str[j++]) { if(str[i] == str[j]) { ct1++; ch1 = str[i]; } } if(ct2 &lt; ct1) { ct2 = ct1; ch2 = ch1; } i++; } return ch2; } 7、查找字符串中出现次数最多的字符并返回该字符，只考虑小写字母，不考虑不同字母出现次数一样多的情况char findch(const char* str){ int i = 0,j = 0,ct1 = 0,ct2 = 0; char ch1 = ‘\0’,ch2 = ‘\0’; while(str[i]) { if(str[i] &lt; &apos;a&apos; || str[i] &gt; &apos;z&apos;) { i++; continue; } j = 0; ct1 = 0; //这两个条件不可忽略 while(str[j++]) { if(str[i] == str[j]) { ct1++; ch1 = str[i]; } } if(ct2 &lt; ct1) { ct2 = ct1; ch2 = ch1; } i++; } return ch2; } 8、输入一个整数n，计算不大于n的数中和7相关的数的个数，包括能被7整出的数和含有字符7的数，例如：输入20，输出3（7、14、17）。int ctseven(int num){ int ct = 0,i = 0,temp1 = 0,temp2 = 0; if(num &lt; 7) { return 0; } for(i = 7;i &lt; num;i++) { if(i % 7 == 0) { ct++; continue; } temp2 = i; while(temp2) { temp1 = temp2 % 10; if(7 == temp1) { ct++; break; } temp2 = temp2 / 10; } } return ct; } 9、输入一个整数将每一位上的奇数放在一个新整数中，高位放在高位，地位在低位。int getnum(int num){ int i = 1,newnum = 0,temp = 0; while(num) { temp = num % 10; if(temp % 2 != 0) { newnum = newnum + temp * i; i *= 10; } num = num / 10; } return newnum; } 10、输入一串数，将其最小的放在第一位，次小的放在最后一位，再小的放在第二位，再再小的放在倒数第二位，以此类推。void get_newnum(int num[],int n){ int i = 0,j = 0,k = 0,t = 0,temp = 0; // t k 两个变量均用于控制数组下标 for(i = 0;i &lt; n-1-k;i++) { for(j = i;j &lt; n-1-k;j++) { if(num[i] &gt; num[j+1]) { temp = num[i]; num[i] = num[j+1]; num[j+1] = temp; } } t++; //算法实现 k控制循环范围 t控制循环数组元素交换 if(t % 2 == 0) { temp = num[i]; num[i] = num[n-i]; num[n-i] = temp; i--; k++; } } } 11、写一个函数，传入参数为应付钱数。返回值为买家最少付出的钱的张数int get MoneyNum(int iInputMoney)例如：买家应付351元，最少张数为5.备注：可支付的钱币只有100、50、10、5、1不考虑2、20以及小数部分。int getct_money(int money){ int ct = 0; ct += money / 100; money %= 100; ct += money / 50; money %= 50; ct += money / 20; money %= 20; ct += money / 10; money %= 10; ct += money / 5; money %= 5; ct += money / 1; money %= 1; return ct; } 12、设有几个人围坐在一圈并按顺时针方向从1到几编号，从第S个人开始进行1到m的报数。报数到第M个人，此人出圈。再从他的下一个人重新开始1到M的报数，如此进行下一直到所有人都出圈为止，输出报数顺序。void getrank(int num[],int n,int num1,int num2,int newnum[]){ struct rank { int number; struct rank next; }; int i = 0,j = 0; struct rank p = NULL; struct rank temp1 = NULL; struct rank temp2 = NULL; struct rank* phead = NULL; phead = p = calloc(1,sizeof(struct rank)); p-&gt;number = num[0]; for(i = 1;i &lt; n;i++) { p-&gt;next = calloc(1,sizeof(struct rank)); p-&gt;next-&gt;number = num[i]; p = p-&gt;next; } p-&gt;next = phead; //形成一个环形链表 while(phead-&gt;number != num1) //找出从谁开始报数 { phead = phead-&gt;next; } for(j = 0;j &lt; n;j++) { for(i = 0;i &lt; num2-1;i++) //报数到num2时跳出循环 phead指向的number就是要出圈的数字 { temp1 = phead; phead = phead-&gt;next; } newnum[j] = phead-&gt;number; temp2 = phead; phead = phead-&gt;next; free(temp2); //出圈后删除该节点 temp1-&gt;next = phead; } } 13、对姓氏进行排名Char str[ ]=”zhang wang li zhao”Char str_ new[ ]=”li wang zhang zhao”void getstr(char str1[],int n,char str2[]){ int i = 0,j = 0,k = 0; //i j k 均用于数组下标 int len = strlen(str1); char str[n]; char temp = NULL; for(i = 0;i &lt; n;i++) { str[i] = calloc(1,len); } i = 0; //while 一定要初始化 while(str1[i]) //str[i++] 不可这样写 { if(str1[i] == &apos; &apos;) { k = 0; j++; i++; //while continue前 i++ continue; } str[j][k] = str1[i]; i++; k++; } for(i = 0;i &lt; n-1;i++) { for(j = i;j &lt; n-1;j++) { if(strcmp(str[i],str[j+1]) &gt; 0) { temp = str[i]; str[i] = str[j+1]; str[j+1] = temp; } } } strcpy(str2,str[0]); for(i = 1;i &lt; n;i++) { strcat(str2,&quot; &quot;); strcat(str2,str[i]); } for(i = 0;i &lt; n;i++) { free(str[i]); } } 14、将一组整数中为奇数的数提取出来，高低位顺序不变。如：8 3 7 9 5 2 1 4—–》3 7 5 1int getodd(int num1[],int n,int num2[]){ int i = 0,j = 0; for(i = 0;i &lt; n;i++) { if(num1[i] % 2 != 0) { num2[j] = num1[i]; j++; } } return j; } 15、一组2n+1个元素的正整形数组，按升序排序，然后将小于中间数值的成员替换为中间的值。（貌似还有：“位置不变”，不过实在不理解其含义，看了例子就不用关心它的意思了），例如：1,2,3,4,5，输出为：3,3,3,4,5，原型：int fun(int arry[],int n,charoutput){return 0;}int fun(int num[],int n,char output){ int i = 0,j = 0,temp = 0; for(i = 0;i &lt; n-1;i++) { for(j = i;j &lt; n-1;j++) { if(num[i] &gt; num[j+1]) { temp = num[i]; num[i] = num[j+1]; num[j+1] = temp; } } } j = n / 2; for(i = 0;i &lt; j;i++) { num[i] = num[j]; } for(i = 0;i &lt; n;i++) { output[i] = num[i] + &apos;0&apos;; } return num[j]; } 16、输入一个四位的十进制整数，编程实现将这四位整数转化为十六进制的字符串，并输出十六进制的字符串（注意负数的处理）int hex_to_str(int num,char str[]){ int i = 0,len = 0,temp = 0; char ch = ‘\0’; while(num) { temp = num &amp; 0xf; if(temp &lt; 10) { str[i] = &apos;0&apos; + temp; } else { str[i] = &apos;a&apos; + temp - 10; } num = num &gt;&gt; 4; if(num &lt; 0) { num = num &amp; 0xfffffff; } i++; } str[i] = &apos;\0&apos;; len = strlen(str); for(i = 0;i &lt; len / 2;i++) { ch = str[i]; str[i] = str[len-1-i]; str[len-1-i] = ch; } return len; } 17、输入：一个四位的整数，比如：2367，输出：2+3+6+7=18int int_to_str(int num,char str[]){ int i = 0,j = 0,k = 0,temp = num,sum = 0; while(temp) { temp /= 10; i++; } int* pnum = calloc(i+1,sizeof(int)); for(j = i-1;j &gt;= 0;j--) { pnum[j] = num % 10; sum += pnum[j]; num = num / 10; } pnum[i] = sum; for(j = 0;j &lt; i*2;j++) { if(j % 2 == 0) { str[j] = pnum[k] + &apos;0&apos;; k++; continue; } str[j] = &apos;+&apos;; } j--; str[j] = &apos;=&apos;; if(sum / 10) { str[j+1] = sum / 10 + &apos;0&apos;; str[j+2] = sum % 10 + &apos;0&apos;; str[j+3] = &apos;\0&apos; free(pnum); return j+3; } str[j+1] = &apos;0&apos; + sum % 10; str[j+2] = &apos;\0&apos; free(pnum); return j+2; } 18,将一个正整数转换为字符串char int_to_str(int num,char str){ int i = 0,j = 0,temp1 = 0,temp2 = num; while(num) { temp1 = num % 10; num = num / 10; j++; } str[j] = &apos;\0&apos;; for(i = j-1;i &gt;= 0;i--) { temp1 = temp2 % 10; str[i] = &apos;0&apos; + temp1; temp2 = temp2 / 10; } return str; } 19，将一个字符串转换为正整数int str_to_int(const char* str){ int i = 0,sum = 0; while(str[i]) { sum = sum * 10 + (str[i] - &apos;0&apos;); i++; } return sum; } 20,从长串中找到连续相同字符最长的字串int get_childstr(const char str,char childstr){ int i = 0,ct1 = 0,ct2 = 0; char ch = ‘\0’; while(str[i]) { ct1 = &apos;\0&apos;; // 要比较 切莫忘记初始化比较量 while(str[i] == str[i+1]) { ct1++; i++; } if(ct2 &lt; ct1) { ct2 = ct1; ch = str[i]; } i++; } for(i = 0;i &lt; ct2+1;i++) { childstr[i] = ch; } childstr[i] = &apos;\0&apos;; return ct2+1; } 21,将一个字符串逆序char* getstr(char str[]){ int i = 0; int len = strlen(str); char ch = ‘\0’; for(i = 0;i &lt; len / 2;i++) { ch = str[i]; str[i] = str[len-i-1]; str[len-i-1] = ch; } return str; } 22,搜索给定的字节void findbyte(const void st,size_t len,char dat){ int i = 0; char str = (char)st; while(str[i]) { if(dat == str[i]) { return str + i; } i++; } return NULL; } 23,将一个链表逆序void oppsite_list(ST head){ ST phead = NULL; ST* P = head; head = head-&gt;next; p-&gt;next = NULL; while(head) // 循环结束后 p 变为头指针 { phead = head-&gt;next head-&gt;next = p; p = head; head = phead; } } 24,判断一个字节有多少个1int getsize(char ch){ int i = 8,temp = 0,ct = 0; while(i–) { temp = ch &amp; 1; if(temp) { ct++; } ch &gt;&gt;= 1; } return ct;} 24,直接插入排序 冒泡排序 选择排序void rank(int num[],int n) // 直接插入{ int i = 0,j = 0,temp = 0; for(i = 1;i &lt; n;i++) { temp = num[i]; for(j = i - 1;j &gt;= 0 &amp;&amp; temp &lt; num[j];j--) // temp&lt;num[j]从小到大 temp&gt;num[j]从大到小 { num[j+1] = num[j]; } num[j+1] = temp; } } void rank(int num[],int n) // 冒泡{ int i = 0,j = 0,temp = 0; for(i = 0;i &lt; n;i++) { for(j = n - 1;j &gt;= i;j--) { if(num[j+1] &lt; num[j]) { temp = num[j+1]; num[j+1] = num[j]; num[i] = temp; } } } } void myrank_min(int num[],int count) // 冒泡{ int i = 0,j = 0,temp = 0; for(i = 0;i &lt; count-1;i++) { for(j = i;j &lt; count-1;j++) { if(num[i] &gt; num[j+1]) { temp = num[i]; num[i] = num[j+1]; num[j+1] = temp; } } } } void rank(int num[],int n) // 选择{ int i = 0,j = 0,k = 0,temp = 0; for(i = 0;i &lt; n;i++) { temp = num[i]; k = i; for(j = i;j &lt; n;j++) { if(temp &gt; num[j]) { temp = num[j]; k = j; } } num[k] = num[i]; num[i] = temp; } } 26,判断一个字符串有多少个单词int getsize(const char* str){ int state = 0,i = 0,ct = 0; while(str[i]) { if(str[i] == &apos; &apos;) { state = 1; i++; continue; } if(state) { state = 0; ct++; } } return ct+1; } ###26,实现strcmpint strcmp(onst char s1,const char s2){ int i = 0; while(s1[i] != &apos;\0&apos; &amp;&amp; s2[i] != &apos;\0&apos;) { if(s1[i] == s2[i]) { i++; continue; } return s1[i] - s2[i]; } if(strlen(s1) == strlen(s2)) { return 0; } return strlen(s1) - strlen(s2); } int strcmp(onst char s1,const char s2){ int i = 0; while(s1[i] != &apos;\0&apos; &amp;&amp; s2[i] != &apos;\0&apos;) { if(s1[i] == s2[i]) { i++; continue; } return s1[i] - s2[i]; } if(s1[i] == &apos;\0&apos;) { return -1; } if(s2[i] == &apos;\0&apos;) { return 1; } return 0; } 总结面试还是看基础]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有趣的C语言小测试]]></title>
    <url>%2F2017%2F09%2F01%2F%E6%9C%89%E8%B6%A3%E7%9A%84C%E8%AF%AD%E8%A8%80%E5%B0%8F%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[引言C语言是其他语言拓展的基石，如对库的支撑，C语言暂时不敢变，变了岂不好多人要失业，高级语言可以玩出很多变化，但是偏底层靠的是基础，俗话说万变不离其宗，基础扎实才是拓展的前提。 题目下面各个题目输出是什么呢？32位操作系统 测试一unsigned int a = 6;int b = -20;(a+b &gt; 0)? puts(“why”) : puts(“I don‘t no”); 测试二int ar[] ={6,7,8,9,10};int ptr=ar; (ptr++)+=123;printf(“%d,%d \n”,ptr,(++ptr));printf(“%d%d%d\n”,ar[0],ar[1],ar[2]); 测试三int a[3] = {1,11,22};int p = a;printf(“p++ = %d\n”,p++);printf(“++p = %d\n”,*++p); 测试四int a[5] = { 1 , 2 , 3 , 4 , 5 };int ptr = (int )( (char) a + 1 );printf(“%#x\n”,ptr); 测试五求一个字符串长度，不要用库函数，不要用中间变量 结果测试一无符号整型问题的答案是输出是“why”。原因是当表达式中存在有符号类型和无符号类型时所有的操作数都自动转换为无符号类型。因此-20变成了一个非常大的正整数，所以该表达式计算出的结果大于0。 测试二输出依次是 8 8 129 7 8拆开后看是这样的ptr += 123；ptr++；++ptr；printf(“%d,%d \n”,ptr,*ptr);printf(“%d%d%d\n”,ar[0],ar[1],ar[2]); 测试三输出为1 22计算顺序printf(“p++ = %d\n”,p);p++;++p;printf(“++p = %d\n”,p); 测试四结果 0x2000000数据在内存的储存形式 测试五可以用递归int getlen(chars){ if(s == ‘\0’) return 0; s++; return getlen(s) + 1;} 总结不要小看一些细小的额东西，有些错误很难发现有可能就是因为这些越细小的基础造成的]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试帖子]]></title>
    <url>%2F2017%2F09%2F01%2F%E6%B5%8B%E8%AF%95%E5%B8%96%E5%AD%90-2%2F</url>
    <content type="text"><![CDATA[定风波三月七日，沙湖道中遇雨。雨具先去，同行皆狼狈，余独不觉，已而遂晴，故作此词。 莫听穿林打叶声，何妨吟啸且徐行。竹杖芒鞋轻胜马，谁怕？一蓑烟雨任平生。料峭春风吹酒醒，微冷，山头斜照却相迎。回首向来萧瑟处，归去，也无风雨也无晴。]]></content>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建个人博客]]></title>
    <url>%2F2017%2F08%2F31%2Fhexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[引言想拥有一个个人博客，利用hexo可以满足基本需求，博客应有的基本功能都可以实现 环境ubantu mac windows 均可 必备git nodejs npm nvm 具体怎么安装百度一下即可方法很多 注意所关联github上个人仓库必须和用户名相同 如用户名为heweiwei 则仓库名应该为heweiwei.github.io 中文乱码解决 vimrc添加一下内容set fileencodings=utf-8,gb2312,gbk,gb18030set termencoding=utf-8set encoding=prc 安装hexo前面各个必备软件安装正常执行 npm install -g hexo-cli 推送到远程hexo init hexowebcd hexoweb/npm installhexo cleanhexo new your post namehexo generatehexo deploy当然这样做之后访问的页面很简单具体修改参见:hexo官方文档 访问浏览器输入yourname.github.io即可访问也可以去域名服务商买一个域名价格不等我买的.top顶级域第一年8块大洋 主题next主题我用的是next主题简单大体参照next官方使用文档就够了更换背景：找一个背景图片放到 hexo（hexo工程文件）themes/next/source/images 下修改themes/next/source/css/_custom/custom.styl文件在文件加上一代码 body { background:url(/images/yourbackGround.jpg);}注意：此方法会应用到全局 标题背景修改next/source/css/_custom/custom.styl添加.site-meta {background: $blue;} //修改为自己喜欢的颜色 文章外观设计基本搞定之后剩下的就是苦力活了参照hexo官方文档基本都能搞定 修改底部一开始我也不知道怎么改,可以参照Codeagles 原创文章按照作者的方法基本上搞定了]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你好世界]]></title>
    <url>%2F2017%2F08%2F30%2Fhello-world%2F</url>
    <content type="text"><![CDATA[欢迎来的 Hexo 的世界! 这是你的第一个帖子.仔细检查一下 documentation 更多信息。如果你在使用Hexo上遇到任何问题，你可以找到答案 troubleshooting 或者你可以询问 GitHub. 快速开始创建第一个帖子1$ hexo new "My New Post" 更多信息: Writing 运行服务器1$ hexo server 更多信息: Server 生成静态文件1$ hexo generate 更多信息: Generating 部署到远程站点1$ hexo deploy 更多信息: Deployment]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
