<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[bind-9.11.2源码安装配置]]></title>
    <url>%2F2017%2F09%2F07%2Fbind-9-11-2%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[安装资源apt yum 均可 安装bind 但这里不做介绍，本文主要介源码安装源码下载地址选择比较稳定的版本进行下载本文用的是最新版本bind-9.11.2 解压tar -zxvf bind-9.11.2.tar.gz 配置./configure –prefix=/usr/local/bind9 –enable-threads –enable-static –enable-ipv6=yes 安装make &amp;&amp; make install 安装结束之后 建立目录结构cd /usr/local/bind9/mkdir var/namedmkdir /usr/local/bind9/var/logstouch var/run/named.pidtouch var/named_dump.dbtouch var/run/named.stats 获取最新的根配置cd var/namedwget ftp://ftp.rs.internic.net/domain/named.rootmv named.root named.ca 配置主配置文件cd /usr/local/bind9/etc/ 具体配置参考百度文库 named.conf options { directory &quot;/usr/local/bind9/var/named&quot;; pid-file &quot;/usr/local/bind9/var/run/named.pid&quot;; dump-file &quot;/usr/local/bind9/var/named_dump.db&quot;; statistics-file &quot;/usr/local/bind9/var/run/named.stats&quot;; }; // Log logging { channel error_log { file &quot;/usr/local/bind9/var/logs/error.log&quot; versions 10 size 32m; severity warning; print-time yes; print-severity yes; print-category yes; }; channel query_log { file &quot;/usr/local/bind9/var/logs/query.log&quot; versions 10 size 32m; severity info; print-time yes; print-severity yes; print-category yes; }; category default { error_log; }; category queries { query_log; }; }; // RNDC key “rndc-key” { algorithm hmac-md5; secret “D1rQg6l6lLExdxGMlJOEuA==”;}; controls { inet 127.0.0.1 port 953 allow { 127.0.0.1; } keys { “rndc-key”; };}; // Cacheing Only Name Server Config zone “.” IN { type hint; file &quot;named.ca&quot;; }; // localhost. zone “localhost” IN { type master; file &quot;localhost.zone&quot;; allow-update { none; }; }; zone “0.0.127.in-addr.arpa” IN { type master; file &quot;localhost.rzone&quot;; allow-update { none; }; }; // abc.com. zone “abc.com” IN { type master; file &quot;abc.com.zone&quot;; allow-update { none; }; }; zone “0.0.10.in-addr.arpa” IN { type master; file &quot;abc.com.rzone&quot;; allow-update { none; }; }; named.ca; This file holds the information on root name servers needed to; initialize cache of Internet domain name servers; (e.g. reference this file in the “cache . “; configuration file of BIND domain name servers).;; This file is made available by InterNIC; under anonymous FTP as; file /domain/named.cache; on server FTP.INTERNIC.NET; -OR- RS.INTERNIC.NET;; last update: August 29, 2017; related version of root zone: 2017082901;; FORMERLY NS.INTERNIC.NET;. 3600000 NS A.ROOT-SERVERS.NET.A.ROOT-SERVERS.NET. 3600000 A 198.41.0.4A.ROOT-SERVERS.NET. 3600000 AAAA 2001:503:ba3e::2:30;; FORMERLY NS1.ISI.EDU;. 3600000 NS B.ROOT-SERVERS.NET.B.ROOT-SERVERS.NET. 3600000 A 192.228.79.201B.ROOT-SERVERS.NET. 3600000 AAAA 2001:500:200::b;; FORMERLY C.PSI.NET;. 3600000 NS C.ROOT-SERVERS.NET.C.ROOT-SERVERS.NET. 3600000 A 192.33.4.12C.ROOT-SERVERS.NET. 3600000 AAAA 2001:500:2::c;; FORMERLY TERP.UMD.EDU;. 3600000 NS D.ROOT-SERVERS.NET.D.ROOT-SERVERS.NET. 3600000 A 199.7.91.13D.ROOT-SERVERS.NET. 3600000 AAAA 2001:500:2d::d;; FORMERLY NS.NASA.GOV;. 3600000 NS E.ROOT-SERVERS.NET.E.ROOT-SERVERS.NET. 3600000 A 192.203.230.10E.ROOT-SERVERS.NET. 3600000 AAAA 2001:500:a8::e;; FORMERLY NS.ISC.ORG;. 3600000 NS F.ROOT-SERVERS.NET.F.ROOT-SERVERS.NET. 3600000 A 192.5.5.241F.ROOT-SERVERS.NET. 3600000 AAAA 2001:500:2f::f;; FORMERLY NS.NIC.DDN.MIL;. 3600000 NS G.ROOT-SERVERS.NET.G.ROOT-SERVERS.NET. 3600000 A 192.112.36.4G.ROOT-SERVERS.NET. 3600000 AAAA 2001:500:12::d0d;; FORMERLY AOS.ARL.ARMY.MIL;. 3600000 NS H.ROOT-SERVERS.NET.H.ROOT-SERVERS.NET. 3600000 A 198.97.190.53H.ROOT-SERVERS.NET. 3600000 AAAA 2001:500:1::53;; FORMERLY NIC.NORDU.NET;. 3600000 NS I.ROOT-SERVERS.NET.I.ROOT-SERVERS.NET. 3600000 A 192.36.148.17I.ROOT-SERVERS.NET. 3600000 AAAA 2001:7fe::53;; OPERATED BY VERISIGN, INC.;. 3600000 NS J.ROOT-SERVERS.NET.J.ROOT-SERVERS.NET. 3600000 A 192.58.128.30J.ROOT-SERVERS.NET. 3600000 AAAA 2001:503:c27::2:30;; OPERATED BY RIPE NCC;. 3600000 NS K.ROOT-SERVERS.NET.K.ROOT-SERVERS.NET. 3600000 A 193.0.14.129K.ROOT-SERVERS.NET. 3600000 AAAA 2001:7fd::1;; OPERATED BY ICANN;. 3600000 NS L.ROOT-SERVERS.NET.L.ROOT-SERVERS.NET. 3600000 A 199.7.83.42L.ROOT-SERVERS.NET. 3600000 AAAA 2001:500:9f::42;; OPERATED BY WIDE;. 3600000 NS M.ROOT-SERVERS.NET.M.ROOT-SERVERS.NET. 3600000 A 202.12.27.33M.ROOT-SERVERS.NET. 3600000 AAAA 2001:dc3::35; End of file localhost.zone$TTL 86400 $ORIGIN localhost. @ IN SOA localhost. root.localhost. ( 2006083100 Serial (YYMMDDSN) 1800 Refresh 300 Retry 3600 Expiry 300 ) Minimum @ IN NS localhost. @ IN A 127.0.0.1 localhost.rzone $TTL 86400 @ IN SOA localhost. root.localhost. ( 2006083100 Serial (YYMMDDSN) 30M Refresh 5M Retry 1H Expire 5M ) Minimum @ IN NS localhost. 1 IN PTR localhost abc.com.zone$TTL 600 $ORIGIN abc.net. @ IN SOA abc.net. webmaster.abc.com. ( 2006083100 Serial (YYMMDDSN) 1800 Refresh 300 Retry 3600 Expiry 300 ) Minimum @ IN NS ns1.abc.com. @ IN A 10.0.0.97 ns1 IN A 10.0.0.97 www IN A 10.0.0.97 web IN CNAME www mail IN MX 10.0.0.97 abc.com.rzone$TTL 86400 @ IN SOA localhost. root.localhost. ( 2006083100 Serial (YYMMDDSN) 30M Refresh 5M Retry 1H Expire 5M ) Minimum @ IN NS localhost. 1 IN PTR localhost 启动/usr/local/bind9/sbin/named -gc /usr/local/bind9/etc/named.conf带日志启动不带日志去掉 -g 参数 启动脚本vim /etc/rc.d/init.d/namedif [ id -u -ne 0 ]thenecho “ERROR:For bind to port 53,must run as root.”exit 1ficase “$1” in start)if [ -x /usr/local/bind9/sbin/named ]; then/usr/local/bind9/sbin/named -c /usr/local/bind9/etc/named.conf &amp;&amp; echo ‘start named [ok]’fi;; stop)kill cat /usr/local/bind9/var/run/named.pid &amp;&amp; echo ‘stop named [ok]’;;restart)echo “restart named”$0 stop$0 start;;*)echo “$0 start | stop | restart”;; esac 启动服务service named start设置为开机启动编辑文件 vim /etc/rc.d/rc.local 添加以下内容即可/etc/rc.d/init.d/named start参考文章 更改首选服务器为自己vim /etc/resolv.confnameserver 127.0.0.1 总结至此一个滑溜溜的DNS 服务器就配置好了 这只是冰山一角]]></content>
      <categories>
        <category>bind</category>
      </categories>
      <tags>
        <tag>DNS</tag>
        <tag>bind</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务器性能测试]]></title>
    <url>%2F2017%2F09%2F06%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[几个术语首先对吞吐量（）、QPS、并发数、响应时间（RT）几个概念一直比较模糊，也不知道哪些指标可以较好的衡量系统的性能。今天特意查了些资料做一些记录：首先看一些概念（来自百度百科） 1. 响应时间(RT)响应时间是指系统对请求作出响应的时间。直观上看，这个指标与人对软件性能的主观感受是非常一致的，因为它完整地记录了整个计算机系统处理请求的时间。由于一个系统通常会提供许多功能，而不同功能的处理逻辑也千差万别，因而不同功能的响应时间也不尽相同，甚至同一功能在不同输入数据的情况下响应时间也不相同。所以，在讨论一个系统的响应时间时，人们通常是指该系统所有功能的平均时间或者所有功能的最大响应时间。当然，往往也需要对每个或每组功能讨论其平均响应时间和最大响应时间。对于单机的没有并发操作的应用系统而言，人们普遍认为响应时间是一个合理且准确的性能指标。需要指出的是，响应时间的绝对值并不能直接反映软件的性能的高低，软件性能的高低实际上取决于用户对该响应时间的接受程度。对于一个游戏软件来说，响应时间小于100毫秒应该是不错的，响应时间在1秒左右可能属于勉强可以接受，如果响应时间达到3秒就完全难以接受了。而对于编译系统来说，完整编译一个较大规模软件的源代码可能需要几十分钟甚至更长时间，但这些响应时间对于用户来说都是可以接受的。 2. 吞吐量(Throughput)吞吐量是指系统在单位时间内处理请求的数量。对于无并发的应用系统而言，吞吐量与响应时间成严格的反比关系，实际上此时吞吐量就是响应时间的倒数。前面已经说过，对于单用户的系统，响应时间或者系统响应时间和应用延迟时间,可以很好地度量系统的性能，但对于并发系统，通常需要用吞吐量作为性能指标。对于一个多用户的系统，如果只有一个用户使用时系统的平均响应时间是t，当有你n个用户使用时，每个用户看到的响应时间通常并不是n×t，而往往比n×t小很多（当然，在某些特殊情况下也可能比n×t大，甚至大很多）。这是因为处理每个请求需要用到很多资源，由于每个请求的处理过程中有许多不走难以并发执行，这导致在具体的一个时间点，所占资源往往并不多。也就是说在处理单个请求时，在每个时间点都可能有许多资源被闲置，当处理多个请求时，如果资源配置合理，每个用户看到的平均响应时间并不随用户数的增加而线性增加。实际上，不同系统的平均响应时间随用户数增加而增长的速度也不大相同，这也是采用吞吐量来度量并发系统的性能的主要原因。一般而言，吞吐量是一个比较通用的指标，两个具有不同用户数和用户使用模式的系统，如果其最大吞吐量基本一致，则可以判断两个系统的处理能力基本一致。 3. 并发用户数并发用户数是指系统可以同时承载的正常使用系统功能的用户的数量。与吞吐量相比，并发用户数是一个更直观但也更笼统的性能指标。实际上，并发用户数是一个非常不准确的指标，因为用户不同的使用模式会导致不同用户在单位时间发出不同数量的请求。一网站系统为例，假设用户只有注册后才能使用，但注册用户并不是每时每刻都在使用该网站，因此具体一个时刻只有部分注册用户同时在线，在线用户就在浏览网站时会花很多时间阅读网站上的信息，因而具体一个时刻只有部分在线用户同时向系统发出请求。这样，对于网站系统我们会有三个关于用户数的统计数字：注册用户数、在线用户数和同时发请求用户数。由于注册用户可能长时间不登陆网站，使用注册用户数作为性能指标会造成很大的误差。而在线用户数和同事发请求用户数都可以作为性能指标。相比而言，以在线用户作为性能指标更直观些，而以同时发请求用户数作为性能指标更准确些。 4. QPS每秒查询率(Query Per Second)每秒查询率QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准，在因特网上，作为域名系统服务器的机器的性能经常用每秒查询率来衡量。对应fetches/sec，即每秒的响应请求数，也即是最大吞吐能力。 从以上概念来看吞吐量和响应时间是衡量系统性能的重要指标，QPS虽然和吞吐量的计量单位不同，但应该是成正比的，任何一个指标都可以含量服务器的并行处理能力。当然Throughput更关心数据量，QPS更关心处理笔数。 QPS提升带来什么？QPS提升说明单台服务器处理能力提升，如果QPS提升1倍，服务器资源减少1半，或者说服务器不变可以支撑2倍的请求量。如何提升QPS？1）减少CPU的使用时间（哪些代码会消耗CPU：循环、字符串拼接\查找\替换、编码\解码、序列化\反序列化、压缩）2）增加CPU的数量3）减少同步锁（如果CPU不能被压到85%以上，并且此时的QPS已经达到了峰值，则说明另有瓶颈，接下去关注内存）RT提升带来什么？响应速度提升说明单词请求的处理速度提升，用户感觉任务处理速度更快，系统反应速度更快。当然在处理能力不变的情况下，RT的提升必然会提升QPS。如何提升RT？1）减少I/O的响应时间2）减少I/O的调用次数3）减少CPU使用时间（当然在I/O占大头的应用里，这方面优化效果肯定不明显）PV=page view 访问量 浏览量TPS=transactions per second 每秒事务数QPS=queries per second 每秒查询数 每秒可以处理多少查询RPS=requests per second 每秒处理的请求数RPS=并发数/平均响应时间 一．系统吞度量要素：一个系统的吞度量（承压能力）与request对CPU的消耗、外部接口、IO等等紧密关联。单个reqeust 对CPU消耗越高，外部系统接口、IO影响速度越慢，系统吞吐能力越低，反之越高。系统吞吐量几个重要参数：QPS（TPS）、并发数、响应时间QPS（TPS）：每秒钟request/事务 数量并发数： 系统同时处理的request/事务数响应时间： 一般取平均响应时间（很多人经常会把并发数和TPS理解混淆）理解了上面三个要素的意义之后，就能推算出它们之间的关系：QPS（TPS）= 并发数/平均响应时间一个系统吞吐量通常由QPS（TPS）、并发数两个因素决定，每套系统这两个值都有一个相对极限值，在应用场景访问压力下，只要某一项达到系统最高值，系统的吞吐量就上不去了，如果压力继续增大，系统的吞吐量反而会下降，原因是系统超负荷工作，上下文切换、内存等等其它消耗导致系统性能下降。决定系统响应时间要素我们做项目要排计划，可以多人同时并发做多项任务，也可以一个人或者多个人串行工作，始终会有一条关键路径，这条路径就是项目的工期。系统一次调用的响应时间跟项目计划一样，也有一条关键路径，这个关键路径是就是系统影响时间；关键路径是有CPU运算、IO、外部系统响应等等组成。 二．系统吞吐量评估：我们在做系统设计的时候就需要考虑CPU运算、IO、外部系统响应因素造成的影响以及对系统性能的初步预估。而通常境况下，我们面对需求，我们评估出来的出来QPS、并发数之外，还有另外一个维度：日PV。通过观察系统的访问日志发现，在用户量很大的情况下，各个时间周期内的同一时间段的访问流量几乎一样。比如工作日的每天早上。只要能拿到日流量图和QPS我们就可以推算日流量。通常的技术方法： 找出系统的最高TPS和日PV，这两个要素有相对比较稳定的关系（除了放假、季节性因素影响之外） 通过压力测试或者经验预估，得出最高TPS，然后跟进1的关系，计算出系统最高的日吞吐量。B2B中文和淘宝面对的客户群不一样，这两个客户群的网络行为不应用，他们之间的TPS和PV关系比例也不一样。 A)淘宝淘宝流量图： 淘宝的TPS和PV之间的关系通常为 最高TPS：PV大约为 1 : 113600 （相当于按最高TPS访问11个小时，这个是商品详情的场景，不同的应用场景会有一些不同）B) B2B中文站B2B的TPS和PV之间的关系不同的系统不同的应用场景比例变化比较大，粗略估计在1 : 8个小时左右的关系（09年对offerdetail的流量分析数据）。旺铺和offerdetail这两个比例相差很大，可能是因为爬虫暂的比例较高的原因导致。在淘宝环境下，假设我们压力测试出的TPS为100，那么这个系统的日吞吐量=10011*3600=396万这个是在简单（单一url）的情况下，有些页面，一个页面有多个request，系统的实际吞吐量还要小。无论有无思考时间（T_think），测试所得的TPS值和并发虚拟用户数(U_concurrent)、Loadrunner读取的交易响应时间（T_response）之间有以下关系（稳定运行情况下）： TPS=U_concurrent / (T_response+T_think)。并发数、QPS、平均响应时间三者之间关系 来源：http://www.cnblogs.com/jackei/ 软件性能测试的基本概念和计算公式一、软件性能的关注点对一个软件做性能测试时需要关注那些性能呢？我们想想在软件设计、部署、使用、维护中一共有哪些角色的参与，然后再考虑这些角色各自关注的性能点是什么，作为一个软件性能测试工程师，我们又该关注什么？首先，开发软件的目的是为了让用户使用，我们先站在用户的角度分析一下，用户需要关注哪些性能。对于用户来说，当点击一个按钮、链接或发出一条指令开始，到系统把结果已用户感知的形式展现出来为止，这个过程所消耗的时间是用户对这个软件性能的直观印象。也就是我们所说的响应时间，当相应时间较小时，用户体验是很好的，当然用户体验的响应时间包括个人主观因素和客观响应时间，在设计软件时，我们就需要考虑到如何更好地结合这两部分达到用户最佳的体验。如：用户在大数据量查询时，我们可以将先提取出来的数据展示给用户，在用户看的过程中继续进行数据检索，这时用户并不知道我们后台在做什么。用户关注的是用户操作的相应时间。其次，我们站在管理员的角度考虑需要关注的性能点。1、 相应时间2、 服务器资源使用情况是否合理3、 应用服务器和数据库资源使用是否合理4、 系统能否实现扩展5、 系统最多支持多少用户访问、系统最大业务处理量是多少6、 系统性能可能存在的瓶颈在哪里7、 更换那些设备可以提高性能8、 系统能否支持7×24小时的业务访问再次，站在开发（设计）人员角度去考虑。1、 架构设计是否合理2、 数据库设计是否合理3、 代码是否存在性能方面的问题4、 系统中是否有不合理的内存使用方式5、 系统中是否存在不合理的线程同步方式6、 系统中是否存在不合理的资源竞争那么站在性能测试工程师的角度，我们要关注什么呢？一句话，我们要关注以上所有的性能点。 二、软件性能的几个主要术语1、响应时间：对请求作出响应所需要的时间网络传输时间：N1+N2+N3+N4应用服务器处理时间：A1+A3数据库服务器处理时间：A2响应时间=N1+N2+N3+N4+A1+A3+A22、并发用户数的计算公式系统用户数：系统额定的用户数量，如一个OA系统，可能使用该系统的用户总数是5000个，那么这个数量，就是系统用户数。同时在线用户数：在一定的时间范围内，最大的同时在线用户数量。同时在线用户数=每秒请求数RPS（吞吐量）+并发连接数+平均用户思考时间平均并发用户数的计算：C=nL / T其中C是平均的并发用户数，n是平均每天访问用户数（login session），L是一天内用户从登录到退出的平均时间（login session的平均时间），T是考察时间长度（一天内多长时间有用户使用系统）并发用户数峰值计算：C^约等于C + 3根号C其中C^是并发用户峰值，C是平均并发用户数，该公式遵循泊松分布理论。3、吞吐量的计算公式指单位时间内系统处理用户的请求数从业务角度看，吞吐量可以用：请求数/秒、页面数/秒、人数/天或处理业务数/小时等单位来衡量从网络角度看，吞吐量可以用：字节/秒来衡量对于交互式应用来说，吞吐量指标反映的是服务器承受的压力，他能够说明系统的负载能力以不同方式表达的吞吐量可以说明不同层次的问题，例如，以字节数/秒方式可以表示数要受网络基础设施、服务器架构、应用服务器制约等方面的瓶颈；已请求数/秒的方式表示主要是受应用服务器和应用代码的制约体现出的瓶颈。当没有遇到性能瓶颈的时候，吞吐量与虚拟用户数之间存在一定的联系，可以采用以下公式计算：F=VU R /其中F为吞吐量，VU表示虚拟用户个数，R表示每个虚拟用户发出的请求数，T表示性能测试所用的时间4、性能计数器是描述服务器或操作系统性能的一些数据指标，如使用内存数、进程时间，在性能测试中发挥着“监控和分析”的作用，尤其是在分析统统可扩展性、进行新能瓶颈定位时有着非常关键的作用。资源利用率：指系统各种资源的使用情况，如cpu占用率为68%，内存占用率为55%，一般使用“资源实际使用/总的资源可用量”形成资源利用率。5、思考时间的计算公式Think Time，从业务角度来看，这个时间指用户进行操作时每个请求之间的时间间隔，而在做新能测试时，为了模拟这样的时间间隔，引入了思考时间这个概念，来更加真实的模拟用户的操作。在吞吐量这个公式中F=VU R / T说明吞吐量F是VU数量、每个用户发出的请求数R和时间T的函数，而其中的R又可以用时间T和用户思考时间TS来计算：R = T / TS下面给出一个计算思考时间的一般步骤：A、首先计算出系统的并发用户数C=nL / T F=R×CB、统计出系统平均的吞吐量F=VU R / T R×C = VU R / TC、统计出平均每个用户发出的请求数量R=uC*T/VUD、根据公式计算出思考时间TS=T/R]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>DNS</tag>
        <tag>QPS</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有趣的linux命令]]></title>
    <url>%2F2017%2F09%2F05%2F%E6%9C%89%E8%B6%A3%E7%9A%84linux%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[fuck命令首先安装pip3 或者 pippip3 install thefuckeval $(thefuck –alias)source ~/.bashrc sl 命令sudo apt install slsl 会看到一辆火车从屏幕闪过 fortune命令sudo apt install fortunefortune cmatrix命令 矩阵效果sudo apt-get install cmatrixcmatrix cal命令打印日历 September 2017Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 910 11 12 13 14 15 1617 18 19 20 21 22 2324 25 26 27 28 29 30 figlet 、toilet命令 艺术字安装同上sudo apt-get install figletsudo apt-get install toiletfiglet i love youtoilet i love you shred 命令 搞破坏 哈哈哈比如把你私藏的种子文件搞乱 无法恢复哦 很炫酷。。。]]></content>
      <tags>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DNS BIND 压力测试 queryperf 使用]]></title>
    <url>%2F2017%2F09%2F05%2FDNS-BIND-%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95-queryperf-%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[引言首先queryperf是bind自带的压力测试软件，使用queryperf可以对DNS服务器作请求测试，操作简单明了易上手，可以多次测试取平均值，特别说明queryperf的测试结果不一定准确，但与实际情况接近，具有一定参考价值。 安装源码安装官网下载bind源码[heweiwei@heweiwei local]$ cd /usr/local/bind-9.11.1/contrib/queryperf[root@heweiwei queryperf]# ./configure[root@heweiwei queryperf]# cp queryperf /usr/bin/ 使用queryperf使用格式：queryperf [-d datafile] [-s server_addr] [-p port] [-q num_queries]-d: 后面接上一个文件，文件的内容是用户对DNS的请求，一行为一条请求，所以为了测试，我们可以在里面写上几千几万条。-s: DNS服务器地址-p: DNS服务器端口-q: 指定查询的输出的最大数量 编辑测试文件[heweiwei@heweiwei ~]$ vim test.txt比如把下面内容 当然这些内容少的可怜，测试可以加入上万条记录www.baidu.com Awww.baidu.cn cnameqq.com Asohu.com Apython.org CNAMEpython.org Aisc.org A163.com A163.com SOA163.com MX163.com ANY163.com CNAMEcsdn.net Awww.jd.com Awww.jd.com NS 执行[heweiwei@heweiwei ~]$ queryperf -d test.txt -s 192.168.6.189 出现下列结果DNS Query Performance Testing ToolVersion: $Id: queryperf.c,v 1.12 2007/09/05 07:36:04 marka Exp $ [Status] Processing input data[Status] Sending queries (beginning with 192.168.6.189)[Timeout] Query timed out: msg id 2[Timeout] Query timed out: msg id 4[Timeout] Query timed out: msg id 5[Timeout] Query timed out: msg id 8[Timeout] Query timed out: msg id 11[Timeout] Query timed out: msg id 14[Status] Testing complete Statistics: Parse input file: once Ended due to: reaching end of file Queries sent: 15 queries Queries completed: 15 queries Queries lost: 0 queries Queries delayed(?): 0 queries RTT max: 1.022373 sec RTT min: 0.015800 sec RTT average: 0.135892 sec RTT std deviation: 0.313435 sec RTT out of range: 0 queries Percentage completed: 100.00% Percentage lost: 0.00% Started at: Tue Sep 5 17:56:57 2017 Finished at: Tue Sep 5 17:57:02 2017 Ran for: 5.000256 seconds Queries per second: 2.999846 qps 总结1、在作服务器的性能测试时，最好不要在服务器平台自身使用测试软件测试，最好换另外一台机器，这样CPU处理的结果会更准确。2、测试时先预估平台会遇到的最大请求数，用这个请求数作测试，量力而为，因为如果服务器遇到大流量的DDOS，单一机器性能再好，也扛不住。3、使用queryperf作性能测试时，最好测试多次，取平均值。4、可以修改配置文件的部分参数测试，如，开启递归，开启查询日志等功能作测试。 特别感谢本文参考文章]]></content>
      <categories>
        <category>DNS服务</category>
      </categories>
      <tags>
        <tag>DNS</tag>
        <tag>BIND</tag>
        <tag>queryper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速入门shell脚本]]></title>
    <url>%2F2017%2F09%2F04%2F%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8shell%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[参考原文地址[快速入门shell脚本]http://c.biancheng.net/cpp/view/2736.html 变量 含义$0 当前脚本的文件名$n 传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2。$# 传递给脚本或函数的参数个数。$ 传递给脚本或函数的所有参数。$@ 传递给脚本或函数的所有参数。被双引号(“ “)包含时，与 $ 稍有不同，下面将会讲到。$? 上个命令的退出状态，或函数的返回值。$$ 当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。 $* 和 $@ 的区别$ 和 $@ 都表示传递给函数或脚本的所有参数，不被双引号(“ “)包含时，都以”$1” “$2” … “$n” 的形式输出所有参数。但是当它们被双引号(“ “)包含时，”$“ 会将所有的参数作为一个整体，以”$1 $2 … $n”的形式输出所有参数；“$@” 会将各个参数分开，以”$1” “$2” … “$n” 的形式输出所有参数。 算术运算符列表a = 10b = 20运算符 说明 举例 加法 expr $a + $b 结果为 30。 减法 expr $a - $b 结果为 -10。 乘法 expr $a \* $b 结果为 200。/ 除法 expr $b / $a 结果为 2。% 取余 expr $b % $a 结果为 0。= 赋值 a=$b 将把变量 b 的值赋给 a。== 相等。用于比较两个数字，相同则返回 true。 [ $a == $b ] 返回 false。!= 不相等。用于比较两个数字，不相同则返回 true。 [ $a != $b ] 返回 true。注意：条件表达式要放在方括号之间，并且要有空格，例如 [$a==$b] 是错误的，必须写成 [ $a == $b ]。 关系运算符列表运算符 说明 举例-eq 检测两个数是否相等，相等返回 true。 [ $a -eq $b ] 返回 true。-ne 检测两个数是否相等，不相等返回 true。 [ $a -ne $b ] 返回 true。-gt 检测左边的数是否大于右边的，如果是，则返回 true。 [ $a -gt $b ] 返回 false。-lt 检测左边的数是否小于右边的，如果是，则返回 true。 [ $a -lt $b ] 返回 true。-ge 检测左边的数是否大等于右边的，如果是，则返回 true。 [ $a -ge $b ] 返回 false。-le 检测左边的数是否小于等于右边的，如果是，则返回 true。 [ $a -le $b ] 返回 true。 布尔运算符列表运算符 说明 举例! 非运算，表达式为 true 则返回 false，否则返回 true。 [ ! false ] 返回 true。-o 或运算，有一个表达式为 true 则返回 true。 [ $a -lt 20 -o $b -gt 100 ] 返回 true。-a 与运算，两个表达式都为 true 才返回 true。 [ $a -lt 20 -a $b -gt 100 ] 返回 false。 字符串运算符列表运算符 说明 举例= 检测两个字符串是否相等，相等返回 true。 [ $a = $b ] 返回 false。!= 检测两个字符串是否相等，不相等返回 true。 [ $a != $b ] 返回 true。-z 检测字符串长度是否为0，为0返回 true。 [ -z $a ] 返回 false。-n 检测字符串长度是否为0，不为0返回 true。 [ -z $a ] 返回 true。str 检测字符串是否为空，不为空返回 true。 [ $a ] 返回 true。 文件测试运算符列表操作符 说明 举例-b file 检测文件是否是块设备文件，如果是，则返回 true。 [ -b $file ] 返回 false。-c file 检测文件是否是字符设备文件，如果是，则返回 true。 [ -b $file ] 返回 false。-d file 检测文件是否是目录，如果是，则返回 true。 [ -d $file ] 返回 false。-f file 检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。 [ -f $file ] 返回 true。-g file 检测文件是否设置了 SGID 位，如果是，则返回 true。 [ -g $file ] 返回 false。-k file 检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。 [ -k $file ] 返回 false。-p file 检测文件是否是具名管道，如果是，则返回 true。 [ -p $file ] 返回 false。-u file 检测文件是否设置了 SUID 位，如果是，则返回 true。 [ -u $file ] 返回 false。-r file 检测文件是否可读，如果是，则返回 true。 [ -r $file ] 返回 true。-w file 检测文件是否可写，如果是，则返回 true。 [ -w $file ] 返回 true。-x file 检测文件是否可执行，如果是，则返回 true。 [ -x $file ] 返回 true。-s file 检测文件是否为空（文件大小是否大于0），不为空返回 true。 [ -s $file ] 返回 true。-e file 检测文件（包括目录）是否存在，如果是，则返回 true。 [ -e $file ] 返回 true。 全部可用的重定向命令列表命令 说明command &gt; file 将输出重定向到 file。command &lt; file 将输入重定向到 file。command &gt;&gt; file 将输出以追加的方式重定向到 file。n &gt; file 将文件描述符为 n 的文件重定向到 file。n &gt;&gt; file 将文件描述符为 n 的文件以追加的方式重定向到 file。n &gt;&amp; m 将输出文件 m 和 n 合并。n &lt;&amp; m 将输入文件 m 和 n 合并。&lt;&lt; tag 将开始标记 tag 和结束标记 tag 之间的内容作为输入。]]></content>
      <categories>
        <category>linux基础</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>inux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[国漫推荐大讲堂]]></title>
    <url>%2F2017%2F09%2F03%2F%E5%9B%BD%E6%BC%AB%E6%8E%A8%E8%8D%90%E5%A4%A7%E8%AE%B2%E5%A0%82%2F</url>
    <content type="text"><![CDATA[动画制作公司比较出名的有玄机科技，虚拟印象，铸梦动画，若森数字。 玄机科技国内动漫制作佼佼者，坊间粉丝说玄机科技必属精品，目前我觉得大部分都不错唯独天逾 秦时明月作为一名骨灰级秦迷，见证了秦时明月每一步成长。 天行九歌擦写不动了…这…]]></content>
      <categories>
        <category>动漫</category>
      </categories>
      <tags>
        <tag>秦时明月</tag>
        <tag>墓王之王</tag>
        <tag>超神学院</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git远程仓库关联]]></title>
    <url>%2F2017%2F09%2F02%2Fgit%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E5%85%B3%E8%81%94%2F</url>
    <content type="text"><![CDATA[引言我的环境：ubantu17.04 其他linux发行版本安装使用大同小异安装git：sudo apt-get install git首先必须有一个githup账号 去官网注册即可 同时绑定邮箱有了账号后创建远程仓库 比如我创建的仓库名字为project 密钥本地创建密钥命令如下ssh-keygen -t rsa -C “邮箱地址”公钥存放在用户主目录 ~/.ssh/id_rsa.pub复制到官网在账户设置一栏添加即可 验证连接验证是否能连接上ssh -T git@github.com输入yes后出现类似以下内容表示已经可以连接Hi he475943497! You’ve successfully authenticated, but GitHub does not provide shell access. 创建本地仓库执行下列命令创建仓库并初始化mkdir projectcd projectgit init 指明用户若之前没有使用git执行以下操作git config –global user.email “邮箱地址”git config –global user.name “用户名” 本地与远程关联并推送touch test.txtgit add test.txtgit commit -m “test”git remote add origin git@github.com:用户名/仓库名.git推送到远程git push -u origin master 第一次提交加-u参数之后提交git add . git commit -m “test” git push 即可 git教程git作为目前最流行的版本管理工具，我觉得很有学习的必要有兴趣的同学可以参考：廖雪峰git教程作者写的很幽默通俗易懂]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux一些命令]]></title>
    <url>%2F2017%2F09%2F01%2Flinux%E4%B9%8Bdig%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[dig1.查看域名的A记录 dig yahoo.com2.查看域名的ip dig yahoo.com +short3.查看域名的MX 记录 dig yahoo.com MX4.查看域名的SOA记录 dig yahoo.com SOA5.查询域名的TTL记录 dig yahoo.com TTL6.查看内容信息 dig yahoo.com +nocomments +noquestion +noauthority +noadditional +nostats7.查询所有的DNS记录类型 dig yahoo.com ANY +noall +answer8.DNS反向查询 dig -x 72.30.38.140 +short9.查询多个DNS记录 dig yahoo.com mx +noall +answer redhat.com ns +noall +answer10.单独查询 dig yahoo.com A/SOA/MX/NS/PTR +noall +answer11.查询所有 dig yahoo.com ANY +noall +answer12.快速回答时，+short dig www.baidu.com AAAA +shor13.+multiline选项获得冗长的多行模式人性化注释的DSN的SOA记录，一般来说，用+multiline选项获得的信息可以显示很多，就像BIND配置文件一样,dig +nocmd baidu.com any +multiline +noall +answer14.跟踪dig的查询路径 dig v.qq.com +trace15.dig qq.com @x.x.x.x findLinux下find命令在目录结构中搜索文件，并执行指定的操作。Linux下find命令提供了相当多的查找条件find pathname -options [-print -exec -ok …] 用于在文件树种查找文件，并作出相应的处理find -atime -2 超找48小时内修改过的文件find . -name “.log” 在当前目录查找 以.log结尾的文件。 “. “代表当前目录find /opt/soft/test/ -perm 777 查找/opt/soft/test/目录下 权限为 777的文件find . -type f -name “.log” 查找当目录，以.log结尾的普通文件find . -type d | sort 查找当前所有目录并排序find . -size +1000c -print 查找当前目录大于1K的文件ubantu 用于16.04以上版本 ubantu 界面设置gsettings set com.canonical.Unity.Launcher launcher-position Bottom 移动到下方gsettings set com.canonical.Unity.Launcher launcher-position Left 移动到左方 vimvim打开一个文件 shift + ： 使用 vsplit 命令再打开一个文件 vsplit + 文件q qall（关闭所有） only（关闭当前）在一般模式下输入“:new /root/2.txt” 新编辑文件2.txtctrl + ww 切换 把正在编辑的文件另存为在一般模式下输入“:w /root/1.txt” 正在编辑文件时，不退出文件仍可以运行linux命令eg：在编辑模式下输入“:! cat /root/1.txt” .查找替换的功能使用例：在10到15行的行首增加“#”在一般模式下输入“:10,15s/^/#/”例：在10到15行的行首去掉“#”在一般模式下输入“:10,15s/^#//”例：在10到15行的行首增加“//”在一般模式下输入“:10,15s/^/\/\//”或者“:10,15s@^@//@”或者“:10,15s#^#//#” 把文件恢复到打开时的状态在一般模式下输入“:e! vim 中 shift + 3 选中单词 可以突出显示这个单词全部 ctrl +n 自动补全 ctrl + p 也一样 删除空行：:%s/^\n$//g 自动对齐 v 进入可视模式后选中要对齐的部分 = 号自动对齐 vim 用swap 文件恢复未保存的文件vim -r filename 后 删除 swap文件vimdiff比较两个文件不同vimdiff /home/heweiwei/dial_cpp/Makefile Makefile.jc或者使用diff命令重定向也可以达到比较效果diff /home/heweiwei/dial_cpp/Makefile Makefile.jc &gt; cmp.txt stat 文件 获取文件详细信息fdisk -l 查看磁盘信息 grep 命令查找指定进程ps -ef|grep svnps -aux|grep svnps -ef|grep svn -c 包含个数ps -ef|grep -c svn 输出test.txt文件中含有从test2.txt文件中读取出的关键词的内容行cat test.txt | grep -f test2.txtcat test.txt | grep -nf test2.txt 从文件中查找关键字grep ‘linux’ test.txtgrep ‘linux’ test.txt test2.txt grep不显示本身进程ps aux|grep [s]shps aux | grep ssh | grep -v “grep” 找出以 u 开头的行内容cat test.txt |grep ^u找出非 u 开头的行内容cat test.txt |grep ^[^u] 输出以hat结尾的行内容cat test.txt |grep hat$ 显示包含ed或者at字符的内容行cat test.txt |grep -E “ed|at” 显示当前目录下面以.txt 结尾的文件中的所有包含每个字符串至少有7个连续小写字符的字符串的行grep ‘[a-z]{7}‘ *.txt scp把本地文件或目录拷到目标机指定目录 对拷文件夹 (包括文件夹本身)scp -r /home/wwwroot/www/charts/util root@192.168.1.65:/home/wwwroot/limesurvey_back/scp /home/wwwroot/www/charts/util root@192.168.1.65:/home/wwwroot/limesurvey_back/scp 对拷文件夹下所有文件 (不包括文件夹本身)scp /home/wwwroot/www/charts/util/* root@192.168.1.65:/home/wwwroot/limesurvey_back/scp 对拷文件并重命名scp /home/wwwroot/www/charts/util/a.txt root@192.168.1.65:/home/wwwroot/limesurvey_back/scp/b.text 把目标机文件或者目录拷贝到本地指定目录scp -r root@192.168.6.240:/home/heweiwei/studytest /home/heweiwei/]]></content>
      <categories>
        <category>linux命令</category>
      </categories>
      <tags>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言面试]]></title>
    <url>%2F2017%2F09%2F01%2FC%E8%AF%AD%E8%A8%80%E9%9D%A2%E8%AF%95%2F</url>
    <content type="text"><![CDATA[引言曾经面试做过的一些面试题目 C/C++题目：1、比较字符串输出它们第一个不同字母的位置，大小写不敏感 // if(str1[i] == (str2[i] | 0x20))int cmpstr(const char str1,const char str2){ int i = 0; while(str1[i] != &apos;\0&apos; &amp;&amp; str2[i] != &apos;\0&apos;) { if(str1[i] == (str2[i] | 0x20)) { i++; continue; } return i+1; } return 0; } 2、判断一个数是不是回文数，数字 1234321。int judge(int num){ int temp1 = 0,temp2 = 0,temp3 = num; while(num) { temp1 = num % 10; temp2 = temp2 * 10 + temp1; num = num / 10; } if(temp2 == temp3) { return 1; } return 0; } 3、比较两字符串长短，并返回结果。int cmpstr(const char str1,const char str2){ int i = 0,j = 0; while(str1[i]) { i++; } while(str2[j]) { j++; } return i - j; } 4、给一个字符串，编程取其中一个特定的字符并输出，返回值 int / char* 字符的偏移量 或 地址int findch(const char* str,char ch){ int i = 0; while(str[i]) { if(ch == str[i]) { return i+1; } i++; } return 0; } 5、是比较两个英文字符串的不相同的字符的位置（忽略字母大小写）int cmpstr(const char str1,const char str2,int site[]){ int i = 0,j = 0; while(str1[i] != &apos;\0&apos; &amp;&amp; str2[i] != &apos;\0&apos;) { if(str1[i] == (str2[i] | 0x20)) { i++; continue; } site[j] = i + 1; j++; i++; } return j; } 6、主函数调用一函数如：检索出字符串中出现次数最多的那个字符，不考虑大小写，然后返回该字符。char findch(const char* str){ int i = 0,j = 0,ct1 = 0,ct2 = 0; char ch1 = ‘\0’,ch2 = ‘\0’; while(str[i]) { j = 0; ct1 = 0; //这两个条件不可忽略 while(str[j++]) { if(str[i] == str[j]) { ct1++; ch1 = str[i]; } } if(ct2 &lt; ct1) { ct2 = ct1; ch2 = ch1; } i++; } return ch2; } 7、查找字符串中出现次数最多的字符并返回该字符，只考虑小写字母，不考虑不同字母出现次数一样多的情况char findch(const char* str){ int i = 0,j = 0,ct1 = 0,ct2 = 0; char ch1 = ‘\0’,ch2 = ‘\0’; while(str[i]) { if(str[i] &lt; &apos;a&apos; || str[i] &gt; &apos;z&apos;) { i++; continue; } j = 0; ct1 = 0; //这两个条件不可忽略 while(str[j++]) { if(str[i] == str[j]) { ct1++; ch1 = str[i]; } } if(ct2 &lt; ct1) { ct2 = ct1; ch2 = ch1; } i++; } return ch2; } 8、输入一个整数n，计算不大于n的数中和7相关的数的个数，包括能被7整出的数和含有字符7的数，例如：输入20，输出3（7、14、17）。int ctseven(int num){ int ct = 0,i = 0,temp1 = 0,temp2 = 0; if(num &lt; 7) { return 0; } for(i = 7;i &lt; num;i++) { if(i % 7 == 0) { ct++; continue; } temp2 = i; while(temp2) { temp1 = temp2 % 10; if(7 == temp1) { ct++; break; } temp2 = temp2 / 10; } } return ct; } 9、输入一个整数将每一位上的奇数放在一个新整数中，高位放在高位，地位在低位。int getnum(int num){ int i = 1,newnum = 0,temp = 0; while(num) { temp = num % 10; if(temp % 2 != 0) { newnum = newnum + temp * i; i *= 10; } num = num / 10; } return newnum; } 10、输入一串数，将其最小的放在第一位，次小的放在最后一位，再小的放在第二位，再再小的放在倒数第二位，以此类推。void get_newnum(int num[],int n){ int i = 0,j = 0,k = 0,t = 0,temp = 0; // t k 两个变量均用于控制数组下标 for(i = 0;i &lt; n-1-k;i++) { for(j = i;j &lt; n-1-k;j++) { if(num[i] &gt; num[j+1]) { temp = num[i]; num[i] = num[j+1]; num[j+1] = temp; } } t++; //算法实现 k控制循环范围 t控制循环数组元素交换 if(t % 2 == 0) { temp = num[i]; num[i] = num[n-i]; num[n-i] = temp; i--; k++; } } } 11、写一个函数，传入参数为应付钱数。返回值为买家最少付出的钱的张数int get MoneyNum(int iInputMoney)例如：买家应付351元，最少张数为5.备注：可支付的钱币只有100、50、10、5、1不考虑2、20以及小数部分。int getct_money(int money){ int ct = 0; ct += money / 100; money %= 100; ct += money / 50; money %= 50; ct += money / 20; money %= 20; ct += money / 10; money %= 10; ct += money / 5; money %= 5; ct += money / 1; money %= 1; return ct; } 12、设有几个人围坐在一圈并按顺时针方向从1到几编号，从第S个人开始进行1到m的报数。报数到第M个人，此人出圈。再从他的下一个人重新开始1到M的报数，如此进行下一直到所有人都出圈为止，输出报数顺序。void getrank(int num[],int n,int num1,int num2,int newnum[]){ struct rank { int number; struct rank next; }; int i = 0,j = 0; struct rank p = NULL; struct rank temp1 = NULL; struct rank temp2 = NULL; struct rank* phead = NULL; phead = p = calloc(1,sizeof(struct rank)); p-&gt;number = num[0]; for(i = 1;i &lt; n;i++) { p-&gt;next = calloc(1,sizeof(struct rank)); p-&gt;next-&gt;number = num[i]; p = p-&gt;next; } p-&gt;next = phead; //形成一个环形链表 while(phead-&gt;number != num1) //找出从谁开始报数 { phead = phead-&gt;next; } for(j = 0;j &lt; n;j++) { for(i = 0;i &lt; num2-1;i++) //报数到num2时跳出循环 phead指向的number就是要出圈的数字 { temp1 = phead; phead = phead-&gt;next; } newnum[j] = phead-&gt;number; temp2 = phead; phead = phead-&gt;next; free(temp2); //出圈后删除该节点 temp1-&gt;next = phead; } } 13、对姓氏进行排名Char str[ ]=”zhang wang li zhao”Char str_ new[ ]=”li wang zhang zhao”void getstr(char str1[],int n,char str2[]){ int i = 0,j = 0,k = 0; //i j k 均用于数组下标 int len = strlen(str1); char str[n]; char temp = NULL; for(i = 0;i &lt; n;i++) { str[i] = calloc(1,len); } i = 0; //while 一定要初始化 while(str1[i]) //str[i++] 不可这样写 { if(str1[i] == &apos; &apos;) { k = 0; j++; i++; //while continue前 i++ continue; } str[j][k] = str1[i]; i++; k++; } for(i = 0;i &lt; n-1;i++) { for(j = i;j &lt; n-1;j++) { if(strcmp(str[i],str[j+1]) &gt; 0) { temp = str[i]; str[i] = str[j+1]; str[j+1] = temp; } } } strcpy(str2,str[0]); for(i = 1;i &lt; n;i++) { strcat(str2,&quot; &quot;); strcat(str2,str[i]); } for(i = 0;i &lt; n;i++) { free(str[i]); } } 14、将一组整数中为奇数的数提取出来，高低位顺序不变。如：8 3 7 9 5 2 1 4—–》3 7 5 1int getodd(int num1[],int n,int num2[]){ int i = 0,j = 0; for(i = 0;i &lt; n;i++) { if(num1[i] % 2 != 0) { num2[j] = num1[i]; j++; } } return j; } 15、一组2n+1个元素的正整形数组，按升序排序，然后将小于中间数值的成员替换为中间的值。（貌似还有：“位置不变”，不过实在不理解其含义，看了例子就不用关心它的意思了），例如：1,2,3,4,5，输出为：3,3,3,4,5，原型：int fun(int arry[],int n,charoutput){return 0;}int fun(int num[],int n,char output){ int i = 0,j = 0,temp = 0; for(i = 0;i &lt; n-1;i++) { for(j = i;j &lt; n-1;j++) { if(num[i] &gt; num[j+1]) { temp = num[i]; num[i] = num[j+1]; num[j+1] = temp; } } } j = n / 2; for(i = 0;i &lt; j;i++) { num[i] = num[j]; } for(i = 0;i &lt; n;i++) { output[i] = num[i] + &apos;0&apos;; } return num[j]; } 16、输入一个四位的十进制整数，编程实现将这四位整数转化为十六进制的字符串，并输出十六进制的字符串（注意负数的处理）int hex_to_str(int num,char str[]){ int i = 0,len = 0,temp = 0; char ch = ‘\0’; while(num) { temp = num &amp; 0xf; if(temp &lt; 10) { str[i] = &apos;0&apos; + temp; } else { str[i] = &apos;a&apos; + temp - 10; } num = num &gt;&gt; 4; if(num &lt; 0) { num = num &amp; 0xfffffff; } i++; } str[i] = &apos;\0&apos;; len = strlen(str); for(i = 0;i &lt; len / 2;i++) { ch = str[i]; str[i] = str[len-1-i]; str[len-1-i] = ch; } return len; } 17、输入：一个四位的整数，比如：2367，输出：2+3+6+7=18int int_to_str(int num,char str[]){ int i = 0,j = 0,k = 0,temp = num,sum = 0; while(temp) { temp /= 10; i++; } int* pnum = calloc(i+1,sizeof(int)); for(j = i-1;j &gt;= 0;j--) { pnum[j] = num % 10; sum += pnum[j]; num = num / 10; } pnum[i] = sum; for(j = 0;j &lt; i*2;j++) { if(j % 2 == 0) { str[j] = pnum[k] + &apos;0&apos;; k++; continue; } str[j] = &apos;+&apos;; } j--; str[j] = &apos;=&apos;; if(sum / 10) { str[j+1] = sum / 10 + &apos;0&apos;; str[j+2] = sum % 10 + &apos;0&apos;; str[j+3] = &apos;\0&apos; free(pnum); return j+3; } str[j+1] = &apos;0&apos; + sum % 10; str[j+2] = &apos;\0&apos; free(pnum); return j+2; } 18,将一个正整数转换为字符串char int_to_str(int num,char str){ int i = 0,j = 0,temp1 = 0,temp2 = num; while(num) { temp1 = num % 10; num = num / 10; j++; } str[j] = &apos;\0&apos;; for(i = j-1;i &gt;= 0;i--) { temp1 = temp2 % 10; str[i] = &apos;0&apos; + temp1; temp2 = temp2 / 10; } return str; } 19，将一个字符串转换为正整数int str_to_int(const char* str){ int i = 0,sum = 0; while(str[i]) { sum = sum * 10 + (str[i] - &apos;0&apos;); i++; } return sum; } 20,从长串中找到连续相同字符最长的字串int get_childstr(const char str,char childstr){ int i = 0,ct1 = 0,ct2 = 0; char ch = ‘\0’; while(str[i]) { ct1 = &apos;\0&apos;; // 要比较 切莫忘记初始化比较量 while(str[i] == str[i+1]) { ct1++; i++; } if(ct2 &lt; ct1) { ct2 = ct1; ch = str[i]; } i++; } for(i = 0;i &lt; ct2+1;i++) { childstr[i] = ch; } childstr[i] = &apos;\0&apos;; return ct2+1; } 21,将一个字符串逆序char* getstr(char str[]){ int i = 0; int len = strlen(str); char ch = ‘\0’; for(i = 0;i &lt; len / 2;i++) { ch = str[i]; str[i] = str[len-i-1]; str[len-i-1] = ch; } return str; } 22,搜索给定的字节void findbyte(const void st,size_t len,char dat){ int i = 0; char str = (char)st; while(str[i]) { if(dat == str[i]) { return str + i; } i++; } return NULL; } 23,将一个链表逆序void oppsite_list(ST head){ ST phead = NULL; ST* P = head; head = head-&gt;next; p-&gt;next = NULL; while(head) // 循环结束后 p 变为头指针 { phead = head-&gt;next head-&gt;next = p; p = head; head = phead; } } 24,判断一个字节有多少个1int getsize(char ch){ int i = 8,temp = 0,ct = 0; while(i–) { temp = ch &amp; 1; if(temp) { ct++; } ch &gt;&gt;= 1; } return ct;} 24,直接插入排序 冒泡排序 选择排序void rank(int num[],int n) // 直接插入{ int i = 0,j = 0,temp = 0; for(i = 1;i &lt; n;i++) { temp = num[i]; for(j = i - 1;j &gt;= 0 &amp;&amp; temp &lt; num[j];j--) // temp&lt;num[j]从小到大 temp&gt;num[j]从大到小 { num[j+1] = num[j]; } num[j+1] = temp; } } void rank(int num[],int n) // 冒泡{ int i = 0,j = 0,temp = 0; for(i = 0;i &lt; n;i++) { for(j = n - 1;j &gt;= i;j--) { if(num[j+1] &lt; num[j]) { temp = num[j+1]; num[j+1] = num[j]; num[i] = temp; } } } } void myrank_min(int num[],int count) // 冒泡{ int i = 0,j = 0,temp = 0; for(i = 0;i &lt; count-1;i++) { for(j = i;j &lt; count-1;j++) { if(num[i] &gt; num[j+1]) { temp = num[i]; num[i] = num[j+1]; num[j+1] = temp; } } } } void rank(int num[],int n) // 选择{ int i = 0,j = 0,k = 0,temp = 0; for(i = 0;i &lt; n;i++) { temp = num[i]; k = i; for(j = i;j &lt; n;j++) { if(temp &gt; num[j]) { temp = num[j]; k = j; } } num[k] = num[i]; num[i] = temp; } } 26,判断一个字符串有多少个单词int getsize(const char* str){ int state = 0,i = 0,ct = 0; while(str[i]) { if(str[i] == &apos; &apos;) { state = 1; i++; continue; } if(state) { state = 0; ct++; } } return ct+1; } ###26,实现strcmpint strcmp(onst char s1,const char s2){ int i = 0; while(s1[i] != &apos;\0&apos; &amp;&amp; s2[i] != &apos;\0&apos;) { if(s1[i] == s2[i]) { i++; continue; } return s1[i] - s2[i]; } if(strlen(s1) == strlen(s2)) { return 0; } return strlen(s1) - strlen(s2); } int strcmp(onst char s1,const char s2){ int i = 0; while(s1[i] != &apos;\0&apos; &amp;&amp; s2[i] != &apos;\0&apos;) { if(s1[i] == s2[i]) { i++; continue; } return s1[i] - s2[i]; } if(s1[i] == &apos;\0&apos;) { return -1; } if(s2[i] == &apos;\0&apos;) { return 1; } return 0; } 总结面试还是看基础]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有趣的C语言小测试]]></title>
    <url>%2F2017%2F09%2F01%2F%E6%9C%89%E8%B6%A3%E7%9A%84C%E8%AF%AD%E8%A8%80%E5%B0%8F%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[引言C语言是其他语言拓展的基石，如对库的支撑，C语言暂时不敢变，变了岂不好多人要失业，高级语言可以玩出很多变化，但是偏底层靠的是基础，俗话说万变不离其宗，基础扎实才是拓展的前提。 题目下面各个题目输出是什么呢？32位操作系统 测试一unsigned int a = 6;int b = -20;(a+b &gt; 0)? puts(“why”) : puts(“I don‘t no”); 测试二int ar[] ={6,7,8,9,10};int ptr=ar; (ptr++)+=123;printf(“%d,%d \n”,ptr,(++ptr));printf(“%d%d%d\n”,ar[0],ar[1],ar[2]); 测试三int a[3] = {1,11,22};int p = a;printf(“p++ = %d\n”,p++);printf(“++p = %d\n”,*++p); 测试四int a[5] = { 1 , 2 , 3 , 4 , 5 };int ptr = (int )( (char) a + 1 );printf(“%#x\n”,ptr); 测试五求一个字符串长度，不要用库函数，不要用中间变量 结果测试一无符号整型问题的答案是输出是“why”。原因是当表达式中存在有符号类型和无符号类型时所有的操作数都自动转换为无符号类型。因此-20变成了一个非常大的正整数，所以该表达式计算出的结果大于0。 测试二输出依次是 8 8 129 7 8拆开后看是这样的ptr += 123；ptr++；++ptr；printf(“%d,%d \n”,ptr,*ptr);printf(“%d%d%d\n”,ar[0],ar[1],ar[2]); 测试三输出为1 22计算顺序printf(“p++ = %d\n”,p);p++;++p;printf(“++p = %d\n”,p); 测试四结果 0x2000000数据在内存的储存形式 测试五可以用递归int getlen(chars){ if(s == ‘\0’) return 0; s++; return getlen(s) + 1;} 总结不要小看一些细小的额东西，有些错误很难发现有可能就是因为这些越细小的基础造成的]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试帖子]]></title>
    <url>%2F2017%2F09%2F01%2F%E6%B5%8B%E8%AF%95%E5%B8%96%E5%AD%90-2%2F</url>
    <content type="text"><![CDATA[定风波三月七日，沙湖道中遇雨。雨具先去，同行皆狼狈，余独不觉，已而遂晴，故作此词。 莫听穿林打叶声，何妨吟啸且徐行。竹杖芒鞋轻胜马，谁怕？一蓑烟雨任平生。料峭春风吹酒醒，微冷，山头斜照却相迎。回首向来萧瑟处，归去，也无风雨也无晴。]]></content>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建个人博客]]></title>
    <url>%2F2017%2F08%2F31%2Fhexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[引言想拥有一个个人博客，利用hexo可以满足基本需求，博客应有的基本功能都可以实现 环境ubantu mac windows 均可 必备git nodejs npm nvm 具体怎么安装百度一下即可方法很多 注意所关联github上个人仓库必须和用户名相同 如用户名为heweiwei 则仓库名应该为heweiwei.github.io 中文乱码解决 vimrc添加一下内容set fileencodings=utf-8,gb2312,gbk,gb18030set termencoding=utf-8set encoding=prc 安装hexo前面各个必备软件安装正常执行 npm install -g hexo-cli 推送到远程hexo init hexowebcd hexoweb/npm installhexo cleanhexo new your post namehexo generatehexo deploy当然这样做之后访问的页面很简单具体修改参见:hexo官方文档 访问浏览器输入yourname.github.io即可访问也可以去域名服务商买一个域名价格不等我买的.top顶级域第一年8块大洋 主题next主题我用的是next主题简单大体参照next官方使用文档就够了更换背景：找一个背景图片放到 hexo（hexo工程文件）themes/next/source/images 下修改themes/next/source/css/_custom/custom.styl文件在文件加上一代码 body { background:url(/images/yourbackGround.jpg);}注意：此方法会应用到全局 标题背景修改next/source/css/_custom/custom.styl添加.site-meta {background: $blue;} //修改为自己喜欢的颜色 文章外观设计基本搞定之后剩下的就是苦力活了参照hexo官方文档基本都能搞定 修改底部一开始我也不知道怎么改,可以参照Codeagles 原创文章按照作者的方法基本上搞定了]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你好世界]]></title>
    <url>%2F2017%2F08%2F30%2Fhello-world%2F</url>
    <content type="text"><![CDATA[欢迎来的 Hexo 的世界! 这是你的第一个帖子.仔细检查一下 documentation 更多信息。如果你在使用Hexo上遇到任何问题，你可以找到答案 troubleshooting 或者你可以询问 GitHub. 快速开始创建第一个帖子1$ hexo new "My New Post" 更多信息: Writing 运行服务器1$ hexo server 更多信息: Server 生成静态文件1$ hexo generate 更多信息: Generating 部署到远程站点1$ hexo deploy 更多信息: Deployment]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
