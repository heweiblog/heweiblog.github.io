<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[国漫推荐大讲堂]]></title>
    <url>%2F2017%2F09%2F03%2F%E5%9B%BD%E6%BC%AB%E6%8E%A8%E8%8D%90%E5%A4%A7%E8%AE%B2%E5%A0%82%2F</url>
    <content type="text"><![CDATA[动画制作公司比较出名的有玄机科技，虚拟印象，铸梦动画，若森数字。 玄机科技国内动漫制作佼佼者，坊间粉丝说玄机科技必属精品，目前我觉得大部分都不错唯独天逾 秦时明月作为一名骨灰级秦迷，见证了秦时明月每一步成长。 天行九歌擦写不动了…这…]]></content>
      <categories>
        <category>动漫</category>
      </categories>
      <tags>
        <tag>秦时明月</tag>
        <tag>墓王之王</tag>
        <tag>超神学院</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux一些命令]]></title>
    <url>%2F2017%2F09%2F01%2Flinux%E4%B9%8Bdig%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[dig1.查看域名的A记录 dig yahoo.com2.查看域名的ip dig yahoo.com +short3.查看域名的MX 记录 dig yahoo.com MX4.查看域名的SOA记录 dig yahoo.com SOA5.查询域名的TTL记录 dig yahoo.com TTL6.查看内容信息 dig yahoo.com +nocomments +noquestion +noauthority +noadditional +nostats7.查询所有的DNS记录类型 dig yahoo.com ANY +noall +answer8.DNS反向查询 dig -x 72.30.38.140 +short9.查询多个DNS记录 dig yahoo.com mx +noall +answer redhat.com ns +noall +answer10.单独查询 dig yahoo.com A/SOA/MX/NS/PTR +noall +answer11.查询所有 dig yahoo.com ANY +noall +answer12.快速回答时，+short dig www.baidu.com AAAA +shor13.+multiline选项获得冗长的多行模式人性化注释的DSN的SOA记录，一般来说，用+multiline选项获得的信息可以显示很多，就像BIND配置文件一样,dig +nocmd baidu.com any +multiline +noall +answer14.跟踪dig的查询路径 dig v.qq.com +trace15.dig qq.com @x.x.x.x findLinux下find命令在目录结构中搜索文件，并执行指定的操作。Linux下find命令提供了相当多的查找条件find pathname -options [-print -exec -ok …] 用于在文件树种查找文件，并作出相应的处理find -atime -2 超找48小时内修改过的文件find . -name “.log” 在当前目录查找 以.log结尾的文件。 “. “代表当前目录find /opt/soft/test/ -perm 777 查找/opt/soft/test/目录下 权限为 777的文件find . -type f -name “.log” 查找当目录，以.log结尾的普通文件find . -type d | sort 查找当前所有目录并排序find . -size +1000c -print 查找当前目录大于1K的文件ubantu 用于16.04以上版本 ubantu 界面设置gsettings set com.canonical.Unity.Launcher launcher-position Bottom 移动到下方gsettings set com.canonical.Unity.Launcher launcher-position Left 移动到左方 vimvim打开一个文件 shift + ： 使用 vsplit 命令再打开一个文件 vsplit + 文件q qall（关闭所有） only（关闭当前）在一般模式下输入“:new /root/2.txt” 新编辑文件2.txtctrl + ww 切换 把正在编辑的文件另存为在一般模式下输入“:w /root/1.txt” 正在编辑文件时，不退出文件仍可以运行linux命令eg：在编辑模式下输入“:! cat /root/1.txt” .查找替换的功能使用例：在10到15行的行首增加“#”在一般模式下输入“:10,15s/^/#/”例：在10到15行的行首去掉“#”在一般模式下输入“:10,15s/^#//”例：在10到15行的行首增加“//”在一般模式下输入“:10,15s/^/\/\//”或者“:10,15s@^@//@”或者“:10,15s#^#//#” 把文件恢复到打开时的状态在一般模式下输入“:e! vim 中 shift + 3 选中单词 可以突出显示这个单词全部 ctrl +n 自动补全 ctrl + p 也一样 删除空行：:%s/^\n$//g 自动对齐 v 进入可视模式后选中要对齐的部分 = 号自动对齐 vim 用swap 文件恢复未保存的文件vim -r filename 后 删除 swap文件vimdiff比较两个文件不同vimdiff /home/heweiwei/dial_cpp/Makefile Makefile.jc或者使用diff命令重定向也可以达到比较效果diff /home/heweiwei/dial_cpp/Makefile Makefile.jc &gt; cmp.txt stat 文件 获取文件详细信息fdisk -l 查看磁盘信息 grep 命令查找指定进程ps -ef|grep svnps -aux|grep svnps -ef|grep svn -c 包含个数ps -ef|grep -c svn 输出test.txt文件中含有从test2.txt文件中读取出的关键词的内容行cat test.txt | grep -f test2.txtcat test.txt | grep -nf test2.txt 从文件中查找关键字grep ‘linux’ test.txtgrep ‘linux’ test.txt test2.txt grep不显示本身进程ps aux|grep [s]shps aux | grep ssh | grep -v “grep” 找出以 u 开头的行内容cat test.txt |grep ^u找出非 u 开头的行内容cat test.txt |grep ^[^u] 输出以hat结尾的行内容cat test.txt |grep hat$ 显示包含ed或者at字符的内容行cat test.txt |grep -E “ed|at” 显示当前目录下面以.txt 结尾的文件中的所有包含每个字符串至少有7个连续小写字符的字符串的行grep ‘[a-z]{7}‘ *.txt scp把本地文件或目录拷到目标机指定目录 对拷文件夹 (包括文件夹本身)scp -r /home/wwwroot/www/charts/util root@192.168.1.65:/home/wwwroot/limesurvey_back/scp /home/wwwroot/www/charts/util root@192.168.1.65:/home/wwwroot/limesurvey_back/scp 对拷文件夹下所有文件 (不包括文件夹本身)scp /home/wwwroot/www/charts/util/* root@192.168.1.65:/home/wwwroot/limesurvey_back/scp 对拷文件并重命名scp /home/wwwroot/www/charts/util/a.txt root@192.168.1.65:/home/wwwroot/limesurvey_back/scp/b.text 把目标机文件或者目录拷贝到本地指定目录scp -r root@192.168.6.240:/home/heweiwei/studytest /home/heweiwei/]]></content>
      <categories>
        <category>linux命令</category>
      </categories>
      <tags>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言面试]]></title>
    <url>%2F2017%2F09%2F01%2FC%E8%AF%AD%E8%A8%80%E9%9D%A2%E8%AF%95%2F</url>
    <content type="text"><![CDATA[引言曾经面试做过的一些面试题目 C/C++题目：1、比较字符串输出它们第一个不同字母的位置，大小写不敏感 // if(str1[i] == (str2[i] | 0x20))int cmpstr(const char str1,const char str2){ int i = 0; while(str1[i] != &apos;\0&apos; &amp;&amp; str2[i] != &apos;\0&apos;) { if(str1[i] == (str2[i] | 0x20)) { i++; continue; } return i+1; } return 0; } 2、判断一个数是不是回文数，数字 1234321。int judge(int num){ int temp1 = 0,temp2 = 0,temp3 = num; while(num) { temp1 = num % 10; temp2 = temp2 * 10 + temp1; num = num / 10; } if(temp2 == temp3) { return 1; } return 0; } 3、比较两字符串长短，并返回结果。int cmpstr(const char str1,const char str2){ int i = 0,j = 0; while(str1[i]) { i++; } while(str2[j]) { j++; } return i - j; } 4、给一个字符串，编程取其中一个特定的字符并输出，返回值 int / char* 字符的偏移量 或 地址int findch(const char* str,char ch){ int i = 0; while(str[i]) { if(ch == str[i]) { return i+1; } i++; } return 0; } 5、是比较两个英文字符串的不相同的字符的位置（忽略字母大小写）int cmpstr(const char str1,const char str2,int site[]){ int i = 0,j = 0; while(str1[i] != &apos;\0&apos; &amp;&amp; str2[i] != &apos;\0&apos;) { if(str1[i] == (str2[i] | 0x20)) { i++; continue; } site[j] = i + 1; j++; i++; } return j; } 6、主函数调用一函数如：检索出字符串中出现次数最多的那个字符，不考虑大小写，然后返回该字符。char findch(const char* str){ int i = 0,j = 0,ct1 = 0,ct2 = 0; char ch1 = ‘\0’,ch2 = ‘\0’; while(str[i]) { j = 0; ct1 = 0; //这两个条件不可忽略 while(str[j++]) { if(str[i] == str[j]) { ct1++; ch1 = str[i]; } } if(ct2 &lt; ct1) { ct2 = ct1; ch2 = ch1; } i++; } return ch2; } 7、查找字符串中出现次数最多的字符并返回该字符，只考虑小写字母，不考虑不同字母出现次数一样多的情况char findch(const char* str){ int i = 0,j = 0,ct1 = 0,ct2 = 0; char ch1 = ‘\0’,ch2 = ‘\0’; while(str[i]) { if(str[i] &lt; &apos;a&apos; || str[i] &gt; &apos;z&apos;) { i++; continue; } j = 0; ct1 = 0; //这两个条件不可忽略 while(str[j++]) { if(str[i] == str[j]) { ct1++; ch1 = str[i]; } } if(ct2 &lt; ct1) { ct2 = ct1; ch2 = ch1; } i++; } return ch2; } 8、输入一个整数n，计算不大于n的数中和7相关的数的个数，包括能被7整出的数和含有字符7的数，例如：输入20，输出3（7、14、17）。int ctseven(int num){ int ct = 0,i = 0,temp1 = 0,temp2 = 0; if(num &lt; 7) { return 0; } for(i = 7;i &lt; num;i++) { if(i % 7 == 0) { ct++; continue; } temp2 = i; while(temp2) { temp1 = temp2 % 10; if(7 == temp1) { ct++; break; } temp2 = temp2 / 10; } } return ct; } 9、输入一个整数将每一位上的奇数放在一个新整数中，高位放在高位，地位在低位。int getnum(int num){ int i = 1,newnum = 0,temp = 0; while(num) { temp = num % 10; if(temp % 2 != 0) { newnum = newnum + temp * i; i *= 10; } num = num / 10; } return newnum; } 10、输入一串数，将其最小的放在第一位，次小的放在最后一位，再小的放在第二位，再再小的放在倒数第二位，以此类推。void get_newnum(int num[],int n){ int i = 0,j = 0,k = 0,t = 0,temp = 0; // t k 两个变量均用于控制数组下标 for(i = 0;i &lt; n-1-k;i++) { for(j = i;j &lt; n-1-k;j++) { if(num[i] &gt; num[j+1]) { temp = num[i]; num[i] = num[j+1]; num[j+1] = temp; } } t++; //算法实现 k控制循环范围 t控制循环数组元素交换 if(t % 2 == 0) { temp = num[i]; num[i] = num[n-i]; num[n-i] = temp; i--; k++; } } } 11、写一个函数，传入参数为应付钱数。返回值为买家最少付出的钱的张数int get MoneyNum(int iInputMoney)例如：买家应付351元，最少张数为5.备注：可支付的钱币只有100、50、10、5、1不考虑2、20以及小数部分。int getct_money(int money){ int ct = 0; ct += money / 100; money %= 100; ct += money / 50; money %= 50; ct += money / 20; money %= 20; ct += money / 10; money %= 10; ct += money / 5; money %= 5; ct += money / 1; money %= 1; return ct; } 12、设有几个人围坐在一圈并按顺时针方向从1到几编号，从第S个人开始进行1到m的报数。报数到第M个人，此人出圈。再从他的下一个人重新开始1到M的报数，如此进行下一直到所有人都出圈为止，输出报数顺序。void getrank(int num[],int n,int num1,int num2,int newnum[]){ struct rank { int number; struct rank next; }; int i = 0,j = 0; struct rank p = NULL; struct rank temp1 = NULL; struct rank temp2 = NULL; struct rank* phead = NULL; phead = p = calloc(1,sizeof(struct rank)); p-&gt;number = num[0]; for(i = 1;i &lt; n;i++) { p-&gt;next = calloc(1,sizeof(struct rank)); p-&gt;next-&gt;number = num[i]; p = p-&gt;next; } p-&gt;next = phead; //形成一个环形链表 while(phead-&gt;number != num1) //找出从谁开始报数 { phead = phead-&gt;next; } for(j = 0;j &lt; n;j++) { for(i = 0;i &lt; num2-1;i++) //报数到num2时跳出循环 phead指向的number就是要出圈的数字 { temp1 = phead; phead = phead-&gt;next; } newnum[j] = phead-&gt;number; temp2 = phead; phead = phead-&gt;next; free(temp2); //出圈后删除该节点 temp1-&gt;next = phead; } } 13、对姓氏进行排名Char str[ ]=”zhang wang li zhao”Char str_ new[ ]=”li wang zhang zhao”void getstr(char str1[],int n,char str2[]){ int i = 0,j = 0,k = 0; //i j k 均用于数组下标 int len = strlen(str1); char str[n]; char temp = NULL; for(i = 0;i &lt; n;i++) { str[i] = calloc(1,len); } i = 0; //while 一定要初始化 while(str1[i]) //str[i++] 不可这样写 { if(str1[i] == &apos; &apos;) { k = 0; j++; i++; //while continue前 i++ continue; } str[j][k] = str1[i]; i++; k++; } for(i = 0;i &lt; n-1;i++) { for(j = i;j &lt; n-1;j++) { if(strcmp(str[i],str[j+1]) &gt; 0) { temp = str[i]; str[i] = str[j+1]; str[j+1] = temp; } } } strcpy(str2,str[0]); for(i = 1;i &lt; n;i++) { strcat(str2,&quot; &quot;); strcat(str2,str[i]); } for(i = 0;i &lt; n;i++) { free(str[i]); } } 14、将一组整数中为奇数的数提取出来，高低位顺序不变。如：8 3 7 9 5 2 1 4—–》3 7 5 1int getodd(int num1[],int n,int num2[]){ int i = 0,j = 0; for(i = 0;i &lt; n;i++) { if(num1[i] % 2 != 0) { num2[j] = num1[i]; j++; } } return j; } 15、一组2n+1个元素的正整形数组，按升序排序，然后将小于中间数值的成员替换为中间的值。（貌似还有：“位置不变”，不过实在不理解其含义，看了例子就不用关心它的意思了），例如：1,2,3,4,5，输出为：3,3,3,4,5，原型：int fun(int arry[],int n,charoutput){return 0;}int fun(int num[],int n,char output){ int i = 0,j = 0,temp = 0; for(i = 0;i &lt; n-1;i++) { for(j = i;j &lt; n-1;j++) { if(num[i] &gt; num[j+1]) { temp = num[i]; num[i] = num[j+1]; num[j+1] = temp; } } } j = n / 2; for(i = 0;i &lt; j;i++) { num[i] = num[j]; } for(i = 0;i &lt; n;i++) { output[i] = num[i] + &apos;0&apos;; } return num[j]; } 16、输入一个四位的十进制整数，编程实现将这四位整数转化为十六进制的字符串，并输出十六进制的字符串（注意负数的处理）int hex_to_str(int num,char str[]){ int i = 0,len = 0,temp = 0; char ch = ‘\0’; while(num) { temp = num &amp; 0xf; if(temp &lt; 10) { str[i] = &apos;0&apos; + temp; } else { str[i] = &apos;a&apos; + temp - 10; } num = num &gt;&gt; 4; if(num &lt; 0) { num = num &amp; 0xfffffff; } i++; } str[i] = &apos;\0&apos;; len = strlen(str); for(i = 0;i &lt; len / 2;i++) { ch = str[i]; str[i] = str[len-1-i]; str[len-1-i] = ch; } return len; } 17、输入：一个四位的整数，比如：2367，输出：2+3+6+7=18int int_to_str(int num,char str[]){ int i = 0,j = 0,k = 0,temp = num,sum = 0; while(temp) { temp /= 10; i++; } int* pnum = calloc(i+1,sizeof(int)); for(j = i-1;j &gt;= 0;j--) { pnum[j] = num % 10; sum += pnum[j]; num = num / 10; } pnum[i] = sum; for(j = 0;j &lt; i*2;j++) { if(j % 2 == 0) { str[j] = pnum[k] + &apos;0&apos;; k++; continue; } str[j] = &apos;+&apos;; } j--; str[j] = &apos;=&apos;; if(sum / 10) { str[j+1] = sum / 10 + &apos;0&apos;; str[j+2] = sum % 10 + &apos;0&apos;; str[j+3] = &apos;\0&apos; free(pnum); return j+3; } str[j+1] = &apos;0&apos; + sum % 10; str[j+2] = &apos;\0&apos; free(pnum); return j+2; } 18,将一个正整数转换为字符串char int_to_str(int num,char str){ int i = 0,j = 0,temp1 = 0,temp2 = num; while(num) { temp1 = num % 10; num = num / 10; j++; } str[j] = &apos;\0&apos;; for(i = j-1;i &gt;= 0;i--) { temp1 = temp2 % 10; str[i] = &apos;0&apos; + temp1; temp2 = temp2 / 10; } return str; } 19，将一个字符串转换为正整数int str_to_int(const char* str){ int i = 0,sum = 0; while(str[i]) { sum = sum * 10 + (str[i] - &apos;0&apos;); i++; } return sum; } 20,从长串中找到连续相同字符最长的字串int get_childstr(const char str,char childstr){ int i = 0,ct1 = 0,ct2 = 0; char ch = ‘\0’; while(str[i]) { ct1 = &apos;\0&apos;; // 要比较 切莫忘记初始化比较量 while(str[i] == str[i+1]) { ct1++; i++; } if(ct2 &lt; ct1) { ct2 = ct1; ch = str[i]; } i++; } for(i = 0;i &lt; ct2+1;i++) { childstr[i] = ch; } childstr[i] = &apos;\0&apos;; return ct2+1; } 21,将一个字符串逆序char* getstr(char str[]){ int i = 0; int len = strlen(str); char ch = ‘\0’; for(i = 0;i &lt; len / 2;i++) { ch = str[i]; str[i] = str[len-i-1]; str[len-i-1] = ch; } return str; } 22,搜索给定的字节void findbyte(const void st,size_t len,char dat){ int i = 0; char str = (char)st; while(str[i]) { if(dat == str[i]) { return str + i; } i++; } return NULL; } 23,将一个链表逆序void oppsite_list(ST head){ ST phead = NULL; ST* P = head; head = head-&gt;next; p-&gt;next = NULL; while(head) // 循环结束后 p 变为头指针 { phead = head-&gt;next head-&gt;next = p; p = head; head = phead; } } 24,判断一个字节有多少个1int getsize(char ch){ int i = 8,temp = 0,ct = 0; while(i–) { temp = ch &amp; 1; if(temp) { ct++; } ch &gt;&gt;= 1; } return ct;} 24,直接插入排序 冒泡排序 选择排序void rank(int num[],int n) // 直接插入{ int i = 0,j = 0,temp = 0; for(i = 1;i &lt; n;i++) { temp = num[i]; for(j = i - 1;j &gt;= 0 &amp;&amp; temp &lt; num[j];j--) // temp&lt;num[j]从小到大 temp&gt;num[j]从大到小 { num[j+1] = num[j]; } num[j+1] = temp; } } void rank(int num[],int n) // 冒泡{ int i = 0,j = 0,temp = 0; for(i = 0;i &lt; n;i++) { for(j = n - 1;j &gt;= i;j--) { if(num[j+1] &lt; num[j]) { temp = num[j+1]; num[j+1] = num[j]; num[i] = temp; } } } } void myrank_min(int num[],int count) // 冒泡{ int i = 0,j = 0,temp = 0; for(i = 0;i &lt; count-1;i++) { for(j = i;j &lt; count-1;j++) { if(num[i] &gt; num[j+1]) { temp = num[i]; num[i] = num[j+1]; num[j+1] = temp; } } } } void rank(int num[],int n) // 选择{ int i = 0,j = 0,k = 0,temp = 0; for(i = 0;i &lt; n;i++) { temp = num[i]; k = i; for(j = i;j &lt; n;j++) { if(temp &gt; num[j]) { temp = num[j]; k = j; } } num[k] = num[i]; num[i] = temp; } } 26,判断一个字符串有多少个单词int getsize(const char* str){ int state = 0,i = 0,ct = 0; while(str[i]) { if(str[i] == &apos; &apos;) { state = 1; i++; continue; } if(state) { state = 0; ct++; } } return ct+1; } ###26,实现strcmpint strcmp(onst char s1,const char s2){ int i = 0; while(s1[i] != &apos;\0&apos; &amp;&amp; s2[i] != &apos;\0&apos;) { if(s1[i] == s2[i]) { i++; continue; } return s1[i] - s2[i]; } if(strlen(s1) == strlen(s2)) { return 0; } return strlen(s1) - strlen(s2); } int strcmp(onst char s1,const char s2){ int i = 0; while(s1[i] != &apos;\0&apos; &amp;&amp; s2[i] != &apos;\0&apos;) { if(s1[i] == s2[i]) { i++; continue; } return s1[i] - s2[i]; } if(s1[i] == &apos;\0&apos;) { return -1; } if(s2[i] == &apos;\0&apos;) { return 1; } return 0; } 总结面试还是看基础]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有趣的C语言小测试]]></title>
    <url>%2F2017%2F09%2F01%2F%E6%9C%89%E8%B6%A3%E7%9A%84C%E8%AF%AD%E8%A8%80%E5%B0%8F%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[引言C语言是其他语言拓展的基石，如对库的支撑，C语言暂时不敢变，变了岂不好多人要失业，高级语言可以玩出很多变化，但是偏底层靠的是基础，俗话说万变不离其宗，基础扎实才是拓展的前提。 题目下面各个题目输出是什么呢？32位操作系统 测试一unsigned int a = 6;int b = -20;(a+b &gt; 0)? puts(“why”) : puts(“I don‘t no”); 测试二int ar[] ={6,7,8,9,10};int ptr=ar; (ptr++)+=123;printf(“%d,%d \n”,ptr,(++ptr));printf(“%d%d%d\n”,ar[0],ar[1],ar[2]); 测试三int a[3] = {1,11,22};int p = a;printf(“p++ = %d\n”,p++);printf(“++p = %d\n”,*++p); 测试四int a[5] = { 1 , 2 , 3 , 4 , 5 };int ptr = (int )( (char) a + 1 );printf(“%#x\n”,ptr); 测试五求一个字符串长度，不要用库函数，不要用中间变量 结果测试一无符号整型问题的答案是输出是“why”。原因是当表达式中存在有符号类型和无符号类型时所有的操作数都自动转换为无符号类型。因此-20变成了一个非常大的正整数，所以该表达式计算出的结果大于0。 测试二输出依次是 8 8 129 7 8拆开后看是这样的ptr += 123；ptr++；++ptr；printf(“%d,%d \n”,ptr,*ptr);printf(“%d%d%d\n”,ar[0],ar[1],ar[2]); 测试三输出为1 22计算顺序printf(“p++ = %d\n”,p);p++;++p;printf(“++p = %d\n”,p); 测试四结果 0x2000000数据在内存的储存形式 测试五可以用递归int getlen(chars){ if(s == ‘\0’) return 0; s++; return getlen(s) + 1;} 总结不要小看一些细小的额东西，有些错误很难发现有可能就是因为这些越细小的基础造成的]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git远程仓库关联]]></title>
    <url>%2F2017%2F09%2F01%2Fgit%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E5%85%B3%E8%81%94%2F</url>
    <content type="text"><![CDATA[引言我的环境：ubantu17.04 其他linux发行版本安装使用大同小异安装git：sudo apt-get install git首先必须有一个githup账号 去官网注册即可 同时绑定邮箱有了账号后创建远程仓库 比如我创建的仓库名字为project 密钥本地创建密钥命令如下ssh-keygen -t rsa -C “邮箱地址”公钥存放在用户主目录 ~/.ssh/id_rsa.pub复制到官网在账户设置一栏添加即可 验证连接验证是否能连接上ssh -T git@github.com输入yes后出现类似以下内容表示已经可以连接Hi he475943497! You’ve successfully authenticated, but GitHub does not provide shell access. 创建本地仓库执行下列命令创建仓库并初始化mkdir projectcd projectgit init 指明用户若之前没有使用git执行以下操作git config –global user.email “邮箱地址”git config –global user.name “用户名” 本地与远程关联并推送touch test.txtgit add test.txtgit commit -m “test”git remote add origin git@github.com:用户名/仓库名.git推送到远程git push -u origin master 第一次提交加-u参数之后提交git add . git commit -m “test” git push 即可 git教程git作为目前最流行的版本管理工具，我觉得很有学习的必要有兴趣的同学可以参考：廖雪峰git教程作者写的很幽默通俗易懂]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试帖子]]></title>
    <url>%2F2017%2F09%2F01%2F%E6%B5%8B%E8%AF%95%E5%B8%96%E5%AD%90-2%2F</url>
    <content type="text"><![CDATA[定风波三月七日，沙湖道中遇雨。雨具先去，同行皆狼狈，余独不觉，已而遂晴，故作此词。 莫听穿林打叶声，何妨吟啸且徐行。竹杖芒鞋轻胜马，谁怕？一蓑烟雨任平生。料峭春风吹酒醒，微冷，山头斜照却相迎。回首向来萧瑟处，归去，也无风雨也无晴。]]></content>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建个人博客]]></title>
    <url>%2F2017%2F08%2F31%2Fhexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[引言想拥有一个个人博客，利用hexo可以满足基本需求，博客应有的基本功能都可以实现 环境ubantu mac windows 均可 必备git nodejs npm nvm 具体怎么安装百度一下即可方法很多 注意所关联github上个人仓库必须和用户名相同 如用户名为heweiwei 则仓库名应该为heweiwei.github.io 中文乱码解决 vimrc添加一下内容set fileencodings=utf-8,gb2312,gbk,gb18030set termencoding=utf-8set encoding=prc 安装hexo前面各个必备软件安装正常执行 npm install -g hexo-cli 推送到远程hexo init hexowebcd hexoweb/npm installhexo cleanhexo new your post namehexo generatehexo deploy当然这样做之后访问的页面很简单具体修改参见:hexo官方文档 访问浏览器输入yourname.github.io即可访问也可以去域名服务商买一个域名价格不等我买的.top顶级域第一年8块大洋 主题next主题我用的是next主题简单大体参照next官方使用文档就够了更换背景：找一个背景图片放到 hexo（hexo工程文件）themes/next/source/images 下修改themes/next/source/css/_custom/custom.styl文件在文件加上一代码 body { background:url(/images/yourbackGround.jpg);}注意：此方法会应用到全局 标题背景修改next/source/css/_custom/custom.styl添加.site-meta {background: $blue;} //修改为自己喜欢的颜色 文章外观设计基本搞定之后剩下的就是苦力活了参照hexo官方文档基本都能搞定 修改底部一开始我也不知道怎么改,可以参照Codeagles 原创文章按照作者的方法基本上搞定了]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
